\section{Módulo Conjunto de Jugadores}
%TODO
% Este diccionario utiliza dos criterios de ordenamiento: por la clave y por el significado. Esto permite definir, obtener y remover cualquier elemento al igual que buscar el mínimo elemento en tiempo logarítmico.

% En el ordenamiento por significado, para los casos en los que hay dos significados iguales, se utiliza nuevamente la clave.

% Usaremos $\#j$ para denotar la cantidad de entradas del diccionario.

\begin{Interfaz}
	\textbf{se explica con}: \tadNombre{Conjunto(Jugador)}. 

	\textbf{géneros}: \TipoVariable{conjJugs}.

	\TituloDis{Operaciones básicas de Conjunto de Jugadores}

	\InterfazFuncion{Vacio}{}{conjJugs}
	{res $\igobs \emptyset$ }
	[$O(1)$]
	[Crea el conjunto vacío]

	\InterfazFuncion{Agregar}{\Inout{c}{conjJugs}, \In{j}{jugador}}{}
	[$c \igobs c_0$]
	{$c \igobs$ Ag($j, c_0$)}
	[$O(log(\#j))$]
	[Agrega al conjunto j]
	[se almacenan copias de $j$.]

	\InterfazFuncion{Pertenece?}{\In{c}{conjJugs}, \In{j}{jugador}}{bool}
	{$res \igobs$ $j \in c$)]}
	[$O(log(\#j))$]
	[devuelve \texttt{true} si el jugador esta en el conjunto.]

	\InterfazFuncion{Borrar}{\Inout{c}{conjJugs}, \In{j}{jugador}}{}
	[$c \igobs c_0$)]
	{$c \igobs$ borrar($j, c_0$)}
	[$O(log(\#j))$]
	[borra un jugador del conjunto.]

\end{Interfaz}


\begin{Representacion}
	\TituloDis{Representación de conjJugs}

	\begin{Estructura}{conjJugs}[eJugs]
		\begin{Tupla}[eJugs]
			\tupItem{raiz}{puntero(Nodo)}
		\end{Tupla}

		~ 

		\begin{Tupla}[Nodo]
			\tupItem{hijoIzq}{puntero(Nodo)}
			\tupItem{hijoDer}{puntero(Nodo)}				
			\tupItem{id}{jugador}
			\tupItem{alto}{nat}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación}

	\begin{enumerate}
		
		\item No hay jugadores repetidos

		\item Un nodo cualquiera del arbol de jugadores su hijo izquierdo tiene menor id y su hijo derecho tiene mayor id

		\item La altura de un Nodo es la altura del hijo con mayor altura mas 1

		\item El factor de balanceo es $\leq$ 1 (donde el factor de balanceo es el modulo de la diferencia de las alturas de los hijos)

	\end{enumerate}
	
	%Agregar menor
	\Rep[eJugs][e]{
		sinRepetidos(e.raiz, $\emptyset$) $\land$\\
		ABB?(e.raiz) $\land$ altoValido?(e.raiz)
	}

	\TituloDis{Función de Abstracción}

	\Abs[eJugs]{conjJugs}[e]{d}
	{($\forall j$: jugador)
	(def?(j, d) = definido?(j, e.raiz) $\yluego$ \\
	(def?(j, d) $\impluego$ obtener(j, d) = obtener(j, e.raiz)))
	}

	\TituloDis{Operaciones auxiliares}

	\tadOperacion{sinRepetidos}{puntero(nodo), conj(nat)}{bool}{}
	\tadOperacion{ABB?}{puntero(Nodo)/nodo}{bool}{}
	\tadOperacion{menor?}{puntero(Nodo)/padre, puntero(Nodo)/hijo}{bool}{padre $\neq$ NULL}
	\tadOperacion{altoValido?}{puntero(nodo)}{bool}{}
	\tadOperacion{mayorAltura}{nat, nat}{nat}{}
	\tadOperacion{factorDeBalanceo}{nat, nat}{nat}{}
	\tadOperacion{cantidadHijos}{puntero(Nodo)}{nat}{}
	\tadOperacion{definido?}{jugador, puntero(nodo)}{bool}{}
	\tadOperacion{obtener}{jugador/j, puntero(nodo)/p}{nat}{definido?(j,p)}


 	~

	\tadAxioma{sinRepetidos(padre, ids)}{
		padre $=$ NULL $\oluego$(padre.id $\not\in$ ids $\land$ \\
		sinRepetidos(padre.hijoIzq, Ag(padre.id, c)) $\land$ \\
		sinRepetidos(padre.hijoDer, Ag(padre.id, c)))
	}

	~

	\tadAxioma{ABB?(nodo)}{
		(nodo = NULL) $\oluego$ \\ 
		(menor?(nodo, (*nodo).hijoDer) $\land$ $\neg$menor?(nodo, (*nodo).hijoIzq) $\land$ \\
		ABB?((*nodo).hijoIzq) $\land$ ABB?((*nodo).hijoDer))
	}

	~

	\tadAxioma{menor?(padre, hijo)}{
		(hijo = NULL) $\oluego$ 
		padre.id $<$ hijo.id)
	}

	~

	\tadAxioma{altoValido?(nodo)}{
		nodo = NULL $\oluego$ \\
		((*nodo).alto = mayorAltura((*nodo).hijoIzq, (*nodo).hijoDer) + 1 $\land$ \\
		factorDeBalanceo(cantidadHijos((*nodo).hijoIzq), cantidadHijos((*nodo).hijoDer)) $\leq$ 1 
	}

	~

	\tadAxioma{mayorAltura(izq, der)}{
		{\IF cantidadHijos(izq) $<$ cantidadHijos(der) THEN
			cantidadHijos(izq)
		ELSE
			cantidadHijos(der)
		FI}
	}

	~

	\tadAxioma{cantidadHijos(nodo)}{
		{\IF nodo = NULL THEN
			0
		ELSE
			$\beta$((*nodo).hijoIzq $\neq$ NULL) + cantidadHijos((*nodo).hijoIzq) + \\
			$\beta$((*nodo).hijoDer $\neq$ NULL) + cantidadHijos((*nodo).hijoDer)		
		FI}
	}

	~

	\tadAxioma{factorDeBalanceo(izq, der)}{
		{\IF izq $<$ der THEN
			der - izq 
		ELSE
			izq - der
		FI}
	}

	~

	\tadAxioma{definido?(j , p)}{
		p $\neq$ NULL $\yluego$ (p.id = j $\lor$ definido?(j, p.hijoIzq) $\lor$ definido?(j, p.hijoDer))
	}

	~

	\tadAxioma{obtener(j , p)}{
		{\IF p.id = j THEN
			p.cantPokemons
		ELSE
			{\IF definido?(j, p.hijoIzq) THEN
				obtener(j, p.hijoIzq)
			ELSE
				obtener(j, p.hijoDer)
			FI}
		FI}
	}

\end{Representacion}

\begin{Algoritmos}
	\TituloDis{Algoritmos de Conjunto de Jugadores}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacio}{}{eJugs}}
		res.raiz $\leftarrow$ NULL\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializan los punteros como nulos.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPertenece?}{\In{c}{eJugs}, \In{j}{jugador}}{bool}}
		res $\leftarrow$ Buscar(p.raiz) $\neq$ NULL\OdeLinea{log(\#j)}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iAgregar}{\Inout{c}{eJugs}, \In{j}{jugador}}{}}
		p.raiz $\leftarrow$ Insertar(j, p.raiz)\OdeLinea{log(\#j)}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iBorrar}{\Inout{c}{eJugs}, \In{j}{jugador}}{}}
		p.raiz $\leftarrow$ Remover(j, p.raiz)\OdeLinea{log(\#j)}
	\end{algorithm}

	\complejidad: $O(log(\#j))$

	\justifcomp: la complejidad de buscar, agregar o eliminar un elemento es de orden de la altura del arbol, que por invariante de AVL sabemos que es $log(\#j)$


	\TituloDis{Algoritmos auxiliares}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Buscar}{\In{j}{jugador}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{\texttt{true}}
		\Post{res es igual al nodo hijo o el que viene por parametro que tenga el id del jugador a menos que no este en cuyo caso en NULL}
		\BlankLine
		\uIf{nodo = NULL \textbf{or} (*nodo).id = jugador}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
		\uElseIf{j $<$ (*nodo).id}{
			res $\leftarrow$ Buscar(j, (*nodo).hijoIzq)\OdeLinea{h}
		}
		\Else{
			res $\leftarrow$ Buscar(j, (*nodo).hijoDer)\OdeLinea{h}
		}
	\end{algorithm}

	\complejidad: $O(h)$ 


	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Insertar}{\In{j}{jugador}, \Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{\texttt{true}}
		\Post{res es igual al mismo nodo que viene por parametro pero con el nuevo nodo(id:j si ya estaba no es nuevo) y balanceado}
		\BlankLine
		\eIf{nodo = NULL}{
			res $\leftarrow$ CrearNodo(j)\OdeLinea{1}
		}{	
			\eIf{j = nodo.id}{
				res $\leftarrow$ nodo\OdeLinea{1}
			}{	
				\eIf{j $<$ nodo.id}{
					(*nodo).hijoIzq $\leftarrow$ Insertar(j, (*nodo).hijoIzq)\OdeLinea{h}
				}{
					(*nodo).hijoDer $\leftarrow$ Insertar(j, (*nodo).hijoDer)\OdeLinea{h}
				}
				res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
			}

		}
	\end{algorithm}

	\complejidad: $O(h)$ 

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Remover}{\In{j}{jugador}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{entre los nodo que desprenden del nodo del parametro se encuentra el id j.} 
		\Post{res es el mismo nodo pero ahora con el hijo removido en esa rama excepto que sea el nodo que hay que remover el cual se convierte en null}
		\BlankLine
		\uIf{nodo = NULL}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
		\uElseIf{j $<$ (*nodo).id}{
			(*nodo).hijoIzq $\leftarrow$ Remover(j, (*nodo).hijoIzq)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\uElseIf{j $>$ (*nodo).id}{
			(*nodo).hijoDer $\leftarrow$ Remover(j, (*nodo).hijoDer)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\Else{
			puntero(Nodo): i $\leftarrow$ (*nodo).hijoIzq\OdeLinea{1}
			puntero(Nodo): d $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
			\eIf{d = NULL}{
				res $\leftarrow$ i\OdeLinea{1}
			}{
				puntero(Nodo): minimo $\leftarrow$ BuscarMinimo(d)\OdeLinea{h}
				minimo.hijoDer $\leftarrow$ RemoverMinimo(d)\OdeLinea{h}
				minimo.hijoIzq $\leftarrow$ i\OdeLinea{1}
				res $\leftarrow$ Balancear(minimo)\OdeLinea{1}
			}
		}
	\end{algorithm}

	\complejidad: $O(h)$ 
	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{true} 
		\Post{res es el puntero al minimo hijo del nodo(o el si es el menor)}
		\BlankLine
		\eIf{(*nodo).hijoIzq = NULL}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}{
			res $\leftarrow$ BuscarMinimo((*nodo).hijoIzq)\OdeLinea{h}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{true} 
		\Post{res es el el mismo nodo pero con el nodo de mas a la izquierda eliminado(al padre del menor, se le pasan los hijos mayores si es que tiene)}
		\BlankLine
		\eIf{(*nodo).hijoIzq = NULL}{
			res $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
		}{
			(*nodo).hijoIzq = RemoverMinimo((*nodo).hijoIzq)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(h)$, donde $h$ es la altura del nodo

	\justifcomp: como sabemos la altura de un nodo es la mayor altura entre sus hijos + 1, como en cada iteración estamos haciendo una llamada recursiva a uno de sus hijos hasta que ese hijo sea nulo, en el peor de los casos llamamos recursivamente al hijo con mayor altura y en cada llamada estamos disminuyendo en 1 la altura.

	La complejidad es equivalente a $log(n)$, donde $n$ es la cantidad de hijos del nodo, ya que al estar ordenado como ABB y balanceado con invariante de AVL, cada llamada recursiva a cada subarbol reduce el tamaño de la entrada aproximadamente por la mitad.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearNodo}{\In{j}{jugador}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		Nodo: nuevo\OdeLinea{1}
		nuevo.hijoIzq $\leftarrow$ NULL\OdeLinea{1}
		nuevo.hijoDer $\leftarrow$ NULL\OdeLinea{1}
		nuevo.alto $\leftarrow$ 1\OdeLinea{1}
		nuevo.id $\leftarrow$ j\OdeLinea{1}
		res $\leftarrow$ \&nuevo\OdeLinea{1}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se crea e inicializa un (*nodo). Como inicialmente se agrega como hoja del arbol, su altura es 1.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{ArreglarAlto}{\Inout{nodo}{puntero(Nodo)}}{}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		nat: alturaIzq $\leftarrow$ Altura((*nodo).hijoIzq)\OdeLinea{1}
		nat: alturaDer $\leftarrow$ Altura((*nodo).hijoDer)\OdeLinea{1}
		\eIf{alturaIzq $<$ alturaDer}{
			(*nodo).altura $\leftarrow$ alturaDer + 1\OdeLinea{1}
		}{
			(*nodo).altura $\leftarrow$ alturaIzq + 1\OdeLinea{1}
		}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se realizan comparaciones para las alturas de los hijos

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Altura}{\In{nodo}{puntero(Nodo)}}{nat}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\eIf{nodo = NULL}{
			res $\leftarrow$ 0\OdeLinea{1}
		}{
			res $\leftarrow$ (*nodo).alto\OdeLinea{1}
		}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se verifica si es nulo o se lee un componente.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Balancear}{\Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		ArreglarAlto(nodo)\OdeLinea{1}
		nat: alturaIzq $\leftarrow$ Altura((*nodo).hijoIzq)\OdeLinea{1}
		nat: alturaDer $\leftarrow$ Altura((*nodo).hijoDer)\OdeLinea{1}
		\uIf{alturaDer $>$ alturaIzq \textbf{and} alturaDer - alturaIzq = 2}{
			\If{Altura((*nodo).hijoDer.hijoIzq) $>$ Altura((*nodo).hijoDer.hijoDer)}{
				(*nodo).hijoDer $\leftarrow$ rotarDer((*nodo).hijoDer\OdeLinea{1}
			}
			res $\leftarrow$ rotarIzq(nodo)\OdeLinea{1}
		}
		\uElseIf{alturaIzq $>$ alturaDer \textbf{and} alturaIzq - alturaDer = 2}{
			\If{Altura((*nodo).hijoIzq.hijoDer) $>$ Altura((*nodo).hijoIzq.hijoIzq)}{
				(*nodo).hijoIzq $\leftarrow$ rotarIzq((*nodo).hijoIzq)\OdeLinea{1}
			}
			res $\leftarrow$ rotarDer(nodo)\OdeLinea{1}
		}
		\Else{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarDer}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		puntero(nodo) : aux $\leftarrow$ (*nodo).hijoIzq\OdeLinea{1}
		(*nodo).hijoIzq $\leftarrow$ aux.hijoDer\OdeLinea{1}
		aux.hijoDer $\leftarrow$ nodo\OdeLinea{1}
		ArreglarAlto(nodo)\OdeLinea{1}
		ArreglarAlto(aux)\OdeLinea{1}
		res $\leftarrow$ aux\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarIzq}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		puntero(nodo) : aux $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
		(*nodo).hijoDer $\leftarrow$ aux.hijoIzq\OdeLinea{1}
		aux.hijoIzq $\leftarrow$ nodo\OdeLinea{1}
		ArreglarAlto(nodo)\OdeLinea{1}
		ArreglarAlto(aux)\OdeLinea{1}
		res $\leftarrow$ aux\OdeLinea{1}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: las rotaciones son una serie de comparasiones y asignaciones de punteros ($\Theta(1)$). El invariante de orden del arbol de búsqueda (ABB) se preserva luego de cada rotación. El invariante de balanceo de AVL se restaura para cada subarbol al final de \texttt{Balancear}, pero no luego de cada rotación individual (puede ser necesario rotar un subarbol de manera temporalmente imbalanceada para restaurar el balance de un arbol).

\end{Algoritmos}