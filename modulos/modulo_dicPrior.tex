\section{Módulo DiccionarioPrioridad}

Este diccionario utiliza dos criterios de ordenamiento: por la clave y por el significado. Esto permite definir, obtener y remover cualquier elemento al igual que buscar el mínimo elemento en tiempo logarítmico.

En el ordenamiento por significado, para los casos en los que hay dos significados iguales, se utiliza nuevamente la clave.

Usaremos $\#j$ para denotar la cantidad de entradas del diccionario.

\begin{Interfaz}
	\textbf{se explica con}: \tadNombre{Diccionario(Jugador, Nat)}. 

	\textbf{géneros}: \TipoVariable{prior}.

	\TituloDis{Operaciones básicas de DiccionarioPrioridad}

	\InterfazFuncion{Vacio}{}{prior}
	{res $\igobs$ vacío}
	[$O(1)$]
	[Crea el diccionario vacío]

	\InterfazFuncion{Definir}{\Inout{p}{prior}, \In{j}{jugador}, \In{c}{nat}}{}
	[$p \igobs p_0$]
	{$p \igobs$ definir($j, c, p_0$)}
	[$O(log(\#j))$]
	[define la cantidad de pokemons de un jugador en el diccionario.]
	[se almacenan copias de $j$ y $c$.]

	\InterfazFuncion{Definido?}{\In{p}{prior}, \In{j}{jugador}}{bool}
	{$res \igobs$ def?($j, p$)]}
	[$O(log(\#j))$]
	[devuelve \texttt{true} si el jugador esta definido en el diccionario.]

	\InterfazFuncion{Borrar}{\Inout{p}{prior}, \In{j}{jugador}}{}
	[$p \igobs p_0 \land$ def?($j, d_0$)]
	{$p \igobs$ borrar($j, p_0$)}
	[$O(log(\#j))$]
	[borra un jugador del diccionario.]

	\InterfazFuncion{Claves}{\In{p}{prior}}{conj(string)}
	{alias($res =$ claves($p$))}
	[$O(\#j)$]
	[devuelve el conjunto de los jugadores del diccionario.]
	[$res$ no es modificable.]

	\InterfazFuncion{Menor}{\Inout{p}{prior}}{jugador}
	[$\neg\emptyset$?(claves($p$))]
	{$res \igobs$ menor($p$, claves($p$))}
	[$O(log(\#j))$]
	[devuelve el jugador con menos pokemons en el diccionario]

  \TituloDis{Especificación de las operaciones auxiliares utilizadas en la interfaz}

  \begin{tad}{Diccionario(Jugador, Nat) Extendido}
    \parskip=0pt
    \tadExtiende{\tadNombre{Diccionario(Jugador, Nat)}}
    
    \tadTitulo{otras operaciones (exportadas)}
    \tadOperacion{menor}{dicc(nat, nat)/d, conj(nat)/c}{nat}{$\neg\emptyset$?(c) $\land$ c $\subseteq$ claves(d)}
    \tadAxiomas
    \tadAxioma{menor(d,c)}{\IF $\emptyset$?(dameUno(c)) THEN 
    	sinUno(c) 
    ELSE 
    	{\IF obtener(dameUno(c), d) $<$ menor(d, sinUno(c)) THEN
    		dameUno(c)
    	ELSE
    		menor(d, sinUno(c))
    	FI}
    FI}
  \end{tad}

\end{Interfaz}


\begin{Representacion}
	\TituloDis{Representación de prior}

	\begin{Estructura}{prior}[dicPri]
		\begin{Tupla}[dicPri]
			\tupItem{raizJugadores}{puntero(Nodo)}
			\tupItem{raizCantidad}{puntero(Nodo)}
			\tupItem{menorID}{jugador}
			\tupItem{menor}{nat}
		\end{Tupla}

		~ 

		\begin{Tupla}[Nodo]
			\tupItem{hijoIzq}{puntero(Nodo)}
			\tupItem{hijoDer}{puntero(Nodo)}				
			\tupItem{id}{jugador}
			\tupItem{cantPokemons}{nat}
			\tupItem{alto}{nat}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación}

	\begin{enumerate}
		
		\item No hay jugadores repetidos

		\item Un nodo cualquiera del arbol de jugadores su hijo izquierdo tiene menor id y su hijo derecho tiene mayor id

		\item Un nodo cualquiera del arbol de cantidades su hijo izquierdo tiene menor o igual cantidad y su hijo derecho tiene mayor o igual cantidad

		\item Un nodo cualquiera del arbol de cantidades su hijo izquierdo si tiene la misma cantidad tiene menor id y lo mismo para su hijo derecho pero mayor id

		\item La altura de un Nodo es la altura del hijo con mayor altura mas 1

		\item El factor de balanceo es $\leq$ 1 (donde el factor de balanceo es el modulo de la diferencia de las alturas de los hijos)

		\item Los arboles tienen los mismos elementos

		\item El menor es realmente el menor

	\end{enumerate}
	
	%Agregar menor
	\Rep[dicPri][e]{
		sinRepetidos(e.raizJugadores, $\emptyset$) $\land$ sinRepetidos(e.raizCantidad, $\emptyset$) $\land$\\
		ABB?(e.raizJugadores) $\land$ altoValido?(e.raizJugadores) $\land$\\
		ABBespecial?(e.raizCantidad) $\land$ altoValido?(e.raizCantidad) $\land$\\
		($\forall$ j: jugador) (definido?(j, e.raizJugadores) = definido?(j, e.raizCantidad) $\yluego$ \\
			definido?(j, e.raizJugadores) $\impluego$ obtener(j, e.raizJugadores) = obtener(j, e.raizCantidad)) $\land$\\
		(e.raizJugadores $\neq$ NULL) $\impluego$ (e.menorID = menor(e.raizCantidad).id $\land$ e.menor = menor(e.raizCantidad).cantPokemons)
	}

	\TituloDis{Función de Abstracción}

	\Abs[dicPri]{prior}[e]{d}
	{($\forall j$: jugador)
	(def?(j, d) = definido?(j, e.raizJugadores) $\yluego$ \\
	(def?(j, d) $\impluego$ obtener(j, d) = obtener(j, e.raizJugadores)))
	}

	\TituloDis{Operaciones auxiliares}

	\tadOperacion{sinRepetidos}{puntero(nodo), conj(nat)}{bool}{}
	\tadOperacion{ABB?}{puntero(Nodo)/nodo}{bool}{}
	\tadOperacion{menor?}{puntero(Nodo)/padre, puntero(Nodo)/hijo}{bool}{padre $\neq$ NULL}
	\tadOperacion{ABBespecial?}{puntero(Nodo)/nodo}{bool}{}
	\tadOperacion{menorEspecial?}{puntero(Nodo)/padre, puntero(Nodo)/hijo}{bool}{padre $\neq$ NULL}
	\tadOperacion{altoValido?}{puntero(nodo)}{bool}{}
	\tadOperacion{mayorAltura}{nat, nat}{nat}{}
	\tadOperacion{factorDeBalanceo}{nat, nat}{nat}{}
	\tadOperacion{cantidadHijos}{puntero(Nodo)}{nat}{}
	\tadOperacion{definido?}{jugador, puntero(nodo)}{bool}{}
	\tadOperacion{obtener}{jugador/j, puntero(nodo)/p}{nat}{definido?(j,p)}
	\tadOperacion{menor}{puntero(nodo)/p}{puntero(nodo)}{{p $\neq$ NULL}}


 	~

	\tadAxioma{sinRepetidos(padre, ids)}{
		padre $=$ NULL $\oluego$(padre.id $\not\in$ ids $\land$ \\
		sinRepetidos(padre.hijoIzq, Ag(padre.id, c)) $\land$ \\
		sinRepetidos(padre.hijoDer, Ag(padre.id, c)))
	}

	~

	\tadAxioma{ABB?(nodo)}{
		(nodo = NULL) $\oluego$ \\ 
		(menor?(nodo, (*nodo).hijoDer) $\land$ $\neg$menor?(nodo, (*nodo).hijoIzq) $\land$ \\
		ABB?((*nodo).hijoIzq) $\land$ ABB?((*nodo).hijoDer))
	}

	~

	\tadAxioma{ABBespecial?(nodo)}{
		(nodo = NULL) $\oluego$ \\ 
		(menorEspecial?(nodo, (*nodo).hijoDer) $\land$ $\neg$menorEspecial?(nodo, (*nodo).hijoIzq) $\land$ \\
		ABBespecial?((*nodo).hijoIzq) $\land$ ABBespecial?((*nodo).hijoDer))
	}

	~

	\tadAxioma{menor?(padre, hijo)}{
		(hijo = NULL) $\oluego$ 
		padre.id $<$ hijo.id)
	}

	~

	\tadAxioma{menorEspecial?(padre, hijo)}{
		(hijo = NULL) $\oluego$ padre.cantPokemons $<$ hijo.cantPokemons $\lor$ \\
		(padre.cantPokemons = hijo.cantPokemons $\land$ padre.id $<$ hijo.id)
	}

	~

	\tadAxioma{altoValido?(nodo)}{
		nodo = NULL $\oluego$ \\
		((*nodo).alto = mayorAltura((*nodo).hijoIzq, (*nodo).hijoDer) + 1 $\land$ \\
		factorDeBalanceo(cantidadHijos((*nodo).hijoIzq), cantidadHijos((*nodo).hijoDer)) $\leq$ 1 
	}

	~

	\tadAxioma{mayorAltura(izq, der)}{
		{\IF cantidadHijos(izq) $<$ cantidadHijos(der) THEN
			cantidadHijos(izq)
		ELSE
			cantidadHijos(der)
		FI}
	}

	~

	\tadAxioma{cantidadHijos(nodo)}{
		{\IF nodo = NULL THEN
			0
		ELSE
			$\beta$((*nodo).hijoIzq $\neq$ NULL) + cantidadHijos((*nodo).hijoIzq) + \\
			$\beta$((*nodo).hijoDer $\neq$ NULL) + cantidadHijos((*nodo).hijoDer)		
		FI}
	}

	~

	\tadAxioma{factorDeBalanceo(izq, der)}{
		{\IF izq $<$ der THEN
			der - izq 
		ELSE
			izq - der
		FI}
	}

	~

	\tadAxioma{definido?(j , p)}{
		p $\neq$ NULL $\yluego$ (p.id = j $\lor$ definido?(j, p.hijoIzq) $\lor$ definido?(j, p.hijoDer))
	}

	~

	\tadAxioma{obtener(j , p)}{
		{\IF p.id = j THEN
			p.cantPokemons
		ELSE
			{\IF definido?(j, p.hijoIzq) THEN
				obtener(j, p.hijoIzq)
			ELSE
				obtener(j, p.hijoDer)
			FI}
		FI}
	}

	~

	\tadAxioma{menor(p)}{
		{\IF p.hijoIzq = NULL THEN
			p
		ELSE
			menor(p.hijoIzq)
		FI}
	}

\end{Representacion}

\begin{Algoritmos}
	\TituloDis{Algoritmos de DiccionarioPrioridad}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacio}{}{dicPri}}
		res.raizJugadores $\leftarrow$ NULL\OdeLinea{1}
		res.raizCantidad $\leftarrow$ NULL\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializan los punteros como nulos.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDefinido?}{\In{p}{dicPri}, \In{j}{jugador}}{bool}}
		res $\leftarrow$ BuscarJ(p.raizJugadores) $\neq$ NULL\OdeLinea{log(\#j)}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDefinir}{\Inout{p}{dicPri}, \In{j}{jugador}, \In{n}{nat}}{}}
		\If{Definido?(p, j)}{
			Borrar(p, j)\OdeLinea{log(\#j)}
		}
		\If{res.raizJugadores = NULL \textbf{or} n $<$ p.menor \textbf{or} (n = p.menor $\land$ j $<$ p.menorId)}{
			p.menor $\leftarrow$ n\OdeLinea{1}
			p.menorId $\leftarrow$ j\OdeLinea{1}
		}
		p.raizJugadores $\leftarrow$ InsertarJ(j, n, p.raizJugadores)\OdeLinea{log(\#j)}
		p.raizCantidad $\leftarrow$ InsertarN(j, n, p.raizCantidad)\OdeLinea{log(\#j)}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iBorrar}{\Inout{p}{dicPri}, \In{j}{jugador}}{}}
		puntero(Nodo): nodo $\leftarrow$ BuscarJ(j, p.raizJugadores)\OdeLinea{log(\#j)}
		p.raizCantidad $\leftarrow$ RemoverN(j, (*nodo).cantPokemons, p.raizCantidad)\OdeLinea{log(\#j)}
		p.raizJugadores $\leftarrow$ RemoverJ(j, p.raizJugadores)\OdeLinea{log(\#j)}
		\If{j = p.menorId $\land$ p.raizCantidad $\neq$ NULL}{
			puntero(Nodo): minimo $\leftarrow$ BuscarMinimo(p.raizCantidad)\OdeLinea{log(\#j)}
			p.menor $\leftarrow$ (*minimo).cantPokemons\OdeLinea{1}
			p.menorId $\leftarrow$ (*minimo).id\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(log(\#j))$

	\justifcomp: la complejidad de buscar o eliminar un elemento es de orden de la altura del arbol, que por invariante de AVL sabemos que es $log(\#j)$

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iMenor}{\In{p}{dicPri}}{jugador}}
		res $\leftarrow$ p.menorId\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo tenemos que acceder a la variable correspondiente

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iClaves}{\In{p}{dicPri}}{conj(Jugador)}}
		res $\leftarrow$ Vacio()\OdeLinea{1}
		AgregarClaves(p.raizJugadores, res)\OdeLinea{\#j}
	\end{algorithm}

	\complejidad: $O(\#j)$

	\justifcomp: el arbol no almacena las claves en una estructura separada, así que las mismas deben obtenerse manualmente recorriendo todo el arbol.

	\TituloDis{Algoritmos auxiliares}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarJ}{\In{j}{jugador}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{\texttt{true}}
		\Post{res es igual al nodo hijo o el que viene por parametro que tenga el id del jugador a menos que no este en cuyo caso en NULL}
		\BlankLine
		\uIf{nodo = NULL \textbf{or} (*nodo).id = jugador}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
		\uElseIf{j $<$ (*nodo).id}{
			res $\leftarrow$ BuscarJ(j, (*nodo).hijoIzq)\OdeLinea{h}
		}
		\Else{
			res $\leftarrow$ BuscarJ(j, (*nodo).hijoDer)\OdeLinea{h}
		}
	\end{algorithm}

	\complejidad: $O(h)$ 


	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{InsertarJ}{\In{j}{jugador}, \In{n}{nat}, \Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{\texttt{true}}
		\Post{res es igual al nodo hijo o el que viene por parametro que tenga el id del jugador a menos que no este en cuyo caso en NULL}
		\BlankLine
		\eIf{nodo = NULL}{
			res $\leftarrow$ CrearNodo(j, n)\OdeLinea{1}
		}{	
			\eIf{j $<$ n.id}{
				(*nodo).hijoIzq $\leftarrow$ InsertarJ(j, n, (*nodo).hijoIzq)\OdeLinea{h}
			}{
				(*nodo).hijoDer $\leftarrow$ InsertarJ(j, n, (*nodo).hijoDer)\OdeLinea{h}
			}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(h)$ 

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverJ}{\In{j}{jugador}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\uIf{nodo = NULL}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
		\uElseIf{j $<$ (*nodo).id}{
			(*nodo).hijoIzq $\leftarrow$ RemoverJ(j, (*nodo).hijoIzq)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\uElseIf{j $>$ (*nodo).id}{
			(*nodo).hijoDer $\leftarrow$ RemoverJ(j, (*nodo).hijoDer)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\Else{
			puntero(Nodo): i $\leftarrow$ (*nodo).hijoIzq\OdeLinea{1}
			puntero(Nodo): d $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
			\eIf{d = NULL}{
				res $\leftarrow$ i\OdeLinea{1}
			}{
				puntero(Nodo): minimo $\leftarrow$ BuscarMinimo(d)\OdeLinea{h}
				minimo.hijoDer $\leftarrow$ RemoverMinimo(d)\OdeLinea{h}
				minimo.hijoIzq $\leftarrow$ i\OdeLinea{1}
				res $\leftarrow$ Balancear(minimo)\OdeLinea{1}
			}
		}
	\end{algorithm}

	\complejidad: $O(h)$ 

	\pre: entre los nodo que desprenden del nodo del parametro se encuentra el id j.

	\post: res es el mismo nodo pero ahora con el hijo removido en esa rama excepto que sea el nodo que hay que remover el cual se convierte en null

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\eIf{(*nodo).hijoIzq = NULL}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}{
			res $\leftarrow$ BuscarMinimo((*nodo).hijoIzq)\OdeLinea{h}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\eIf{(*nodo).hijoIzq = NULL}{
			res $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
		}{
			(*nodo).hijoIzq = RemoverMinimo((*nodo).hijoIzq)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarN}{\In{j}{jugador}, \In{n}{nat} \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\eIf{nodo = NULL \textbf{or} ((*nodo).id = jugador \textbf{and} (*nodo).cantPokemons = n)}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}{
			\eIf{n $<$ (*nodo).cantPokemons \textbf{or} (n = (*nodo).cantPokemons \textbf{and} j $<$ (*nodo).id)}{
				res $\leftarrow$ BuscarN(j, n, (*nodo).hijoIzq)\OdeLinea{h}
			}{
				res $\leftarrow$ BuscarN(j, n, (*nodo).hijoDer)\OdeLinea{h}
			}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{InsertarN}{\In{j}{jugador}, \In{n}{nat}, \Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\eIf{nodo = NULL}{
			res $\leftarrow$ CrearNodo(j, n)\OdeLinea{1}
		}{	
			\eIf{n $<$ (*nodo).cantPokemons \textbf{or} (n = (*nodo).cantPokemons \textbf{and} j $<$ (*nodo).id)}{
				(*nodo).hijoIzq $\leftarrow$ InsertarN(j, n, (*nodo).hijoIzq)\OdeLinea{h}
			}{
				(*nodo).hijoDer $\leftarrow$ InsertarN(j, n, (*nodo).hijoDer)\OdeLinea{h}
			}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverN}{\In{j}{jugador}, \In{n}{nat}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\uIf{nodo = NULL}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
		\uElseIf{n $<$ (*nodo).cantPokemons \textbf{or} (n = (*nodo).cantPokemons \textbf{and} j $<$ (*nodo).id)}{
			(*nodo).hijoIzq $\leftarrow$ RemoverN(j, n, (*nodo).hijoIzq)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\uElseIf{n $>$ (*nodo).cantPokemons \textbf{or} (n = (*nodo).cantPokemons \textbf{and} j $>$ (*nodo).id)}{
			(*nodo).hijoDer $\leftarrow$ RemoverN(j, n, (*nodo).hijoDer)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\Else{
			puntero(Nodo): i $\leftarrow$ (*nodo).hijoIzq\OdeLinea{1}
			puntero(Nodo): d $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
			\eIf{d = NULL}{
				res $\leftarrow$ i\OdeLinea{1}
			}{	
				puntero(Nodo): minimo $\leftarrow$ BuscarMinimo(d)\OdeLinea{h}
				minimo.hijoDer $\leftarrow$ RemoverMinimo(d)\OdeLinea{h}
				minimo.hijoIzq $\leftarrow$ i\OdeLinea{1}
				res $\leftarrow$ Balancear(minimo)\OdeLinea{1}
			}
		}
	\end{algorithm}

	\complejidad: $O(h)$, donde $h$ es la altura del nodo

	\justifcomp: como sabemos la altura de un nodo es la mayor altura entre sus hijos + 1, como en cada iteración estamos haciendo una llamada recursiva a uno de sus hijos hasta que ese hijo sea nulo, en el peor de los casos llamamos recursivamente al hijo con mayor altura y en cada llamada estamos disminuyendo en 1 la altura.

	La complejidad es equivalente a $log(n)$, donde $n$ es la cantidad de hijos del nodo, ya que al estar ordenado como ABB y balanceado con invariante de AVL, cada llamada recursiva a cada subarbol reduce el tamaño de la entrada aproximadamente por la mitad.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{AgregarClaves}{\In{nodo}{Nodo}, \Inout{c}{conj(Jugador)}}{}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\If{nodo $\neq$ NULL}{
			AgregarRapido(c, (*nodo).id)\OdeLinea{1}
			AgregarClaves((*nodo).hijoIzq, c)\OdeLinea{\#j}
			AgregarClaves((*nodo).hijoDer, c)\OdeLinea{\#j}
		}
	\end{algorithm}
	
	\complejidad: $O(\#j)$

	\justifcomp: el arbol no almacena las claves en una estructura separada, así que las mismas deben obtenerse manualmente recorriendo todo el arbol.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearNodo}{\In{j}{jugador}, \In{n}{nat}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		Nodo: nuevo\OdeLinea{1}
		nuevo.hijoIzq $\leftarrow$ NULL\OdeLinea{1}
		nuevo.hijoDer $\leftarrow$ NULL\OdeLinea{1}
		nuevo.alto $\leftarrow$ 1\OdeLinea{1}
		nuevo.id $\leftarrow$ j\OdeLinea{1}
		nuevo.cantPokemons $\leftarrow$ n\OdeLinea{1}
		res $\leftarrow$ \&nuevo\OdeLinea{1}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se crea e inicializa un (*nodo). Como inicialmente se agrega como hoja del arbol, su altura es 1.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{ArreglarAlto}{\Inout{nodo}{puntero(Nodo)}}{}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		nat: alturaIzq $\leftarrow$ Altura((*nodo).hijoIzq)\OdeLinea{1}
		nat: alturaDer $\leftarrow$ Altura((*nodo).hijoDer)\OdeLinea{1}
		\eIf{alturaIzq $<$ alturaDer}{
			(*nodo).altura $\leftarrow$ alturaDer + 1\OdeLinea{1}
		}{
			(*nodo).altura $\leftarrow$ alturaIzq + 1\OdeLinea{1}
		}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se realizan comparaciones para las alturas de los hijos

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Altura}{\In{nodo}{puntero(Nodo)}}{nat}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		\eIf{nodo = NULL}{
			res $\leftarrow$ 0\OdeLinea{1}
		}{
			res $\leftarrow$ (*nodo).alto\OdeLinea{1}
		}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se verifica si es nulo o se lee un componente.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Balancear}{\Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		ArreglarAlto(nodo)\OdeLinea{1}
		nat: alturaIzq $\leftarrow$ Altura((*nodo).hijoIzq)\OdeLinea{1}
		nat: alturaDer $\leftarrow$ Altura((*nodo).hijoDer)\OdeLinea{1}
		\uIf{alturaDer $>$ alturaIzq \textbf{and} alturaDer - alturaIzq = 2}{
			\If{Altura((*nodo).hijoDer.hijoIzq) $>$ Altura((*nodo).hijoDer.hijoDer)}{
				(*nodo).hijoDer $\leftarrow$ rotarDer((*nodo).hijoDer\OdeLinea{1}
			}
			res $\leftarrow$ rotarIzq(nodo)\OdeLinea{1}
		}
		\uElseIf{alturaIzq $>$ alturaDer \textbf{and} alturaIzq - alturaDer = 2}{
			\If{Altura((*nodo).hijoIzq.hijoDer) $>$ Altura((*nodo).hijoIzq.hijoIzq)}{
				(*nodo).hijoIzq $\leftarrow$ rotarIzq((*nodo).hijoIzq)\OdeLinea{1}
			}
			res $\leftarrow$ rotarDer(nodo)\OdeLinea{1}
		}
		\Else{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarDer}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		puntero(nodo) : aux $\leftarrow$ (*nodo).hijoIzq\OdeLinea{1}
		(*nodo).hijoIzq $\leftarrow$ aux.hijoDer\OdeLinea{1}
		aux.hijoDer $\leftarrow$ nodo\OdeLinea{1}
		ArreglarAlto(nodo)\OdeLinea{1}
		ArreglarAlto(aux)\OdeLinea{1}
		res $\leftarrow$ aux\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarIzq}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		% TODO
		\Pre{TODO} 
		\Post{TODO}
		\BlankLine
		puntero(nodo) : aux $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
		(*nodo).hijoDer $\leftarrow$ aux.hijoIzq\OdeLinea{1}
		aux.hijoIzq $\leftarrow$ nodo\OdeLinea{1}
		ArreglarAlto(nodo)\OdeLinea{1}
		ArreglarAlto(aux)\OdeLinea{1}
		res $\leftarrow$ aux\OdeLinea{1}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: las rotaciones son una serie de comparasiones y asignaciones de punteros ($\Theta(1)$). El invariante de orden del arbol de búsqueda (ABB) se preserva luego de cada rotación. El invariante de balanceo de AVL se restaura para cada subarbol al final de \texttt{Balancear}, pero no luego de cada rotación individual (puede ser necesario rotar un subarbol de manera temporalmente imbalanceada para restaurar el balance de un arbol).

\end{Algoritmos}