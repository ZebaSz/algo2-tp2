\section{Módulo Diccionario de Prioridad de atrape}
	Description %%TODO 

\begin{Interfaz}
	\textbf{se explica con}: \tadNombre{Diccionario(Jugador, Nat)}. 

	\textbf{géneros}: \TipoVariable{prior}.

	\TituloDis{Operaciones básicas de Diccionario de Prioridad de atrape}

	\InterfazFuncion{Vacio}{}{prior}
	{res $\igobs$ vacío}
	[$O(1)$]
	[Crea el diccionario vacío]

	\InterfazFuncion{Definir}{\Inout{p}{prior}, \In{j}{jugador}, \In{c}{nat}}{}
	[$p \igobs p_0$]
	{$p \igobs$ definir($j, c, p_0$)}
	[$log(\#j)$]
	[define la cantidad de pokemons de un jugador en el diccionario.]
	[se almacenan copias de $j$ y $c$.]

	\InterfazFuncion{Definido?}{\In{p}{prior}, \In{j}{jugador}}{bool}
	{$res \igobs$ def?($j, p$)]}
	[$log(\#j)$]
	[devuelve \texttt{true} si el jugador esta definido en el diccionario.]

	\InterfazFuncion{Borrar}{\Inout{p}{prior}, \In{j}{jugador}}{}
	[$p \igobs p_0 \land$ def?($j, d_0$)]
	{$p \igobs$ borrar($j, p_0$)}
	[$log(\#j)$]
	[borra un jugador del diccionario.]

	\InterfazFuncion{Claves}{\In{p}{prior}}{conj(string)}
	{alias($res =$ claves($p$))}
	[]%O de N
	[devuelve el conjunto de los jugadores del diccionario.]
	[$res$ no es modificable.]

	\InterfazFuncion{Menor}{\Inout{p}{prior}}{jugador}
	[$\neg\emptyset$?(claves($p$))]
	{$res \igobs$ menor($p$, claves($p$))}
	[$log(\#j)$]
	[devuelve el jugador con menos pokemons en el diccionario]
	[]

  \TituloDis{Especificación de las operaciones auxiliares utilizadas en la interfaz}

  \begin{tad}{Diccionario(Jugador, Nat) Extendido}
    \parskip=0pt
    \tadExtiende{\tadNombre{Diccionario(Jugador, Nat)}}
    
    \tadTitulo{otras operaciones (exportadas)}
    \tadOperacion{menor}{dicc(nat, nat)/d, conj(nat)/c}{nat}{$\neg\emptyset$?(c) $\land$ c $\subseteq$ claves(d)}
    \tadAxiomas
    \tadAxioma{menor(d,c)}{\IF $\emptyset$?(dameUno(c)) THEN 
    	sinUno(c) 
    ELSE 
    	{\IF obtener(dameUno(c), d) $<$ menor(d, sinUno(c)) THEN
    		dameUno(c)
    	ELSE
    		menor(d, sinUno(c))
    	FI}
    FI}
  \end{tad}

\end{Interfaz}


\begin{Representacion}
	\TituloDis{Representación de prior}

	\begin{Estructura}{ prior }[ePrior]
		\begin{Tupla}[ePrior]
			\tupItem{raizJugadores}{puntero(Nodo)}
			\tupItem{raizCantidad}{puntero(Nodo)}
		\end{Tupla}
		\begin{Tupla}[Nodo]
			\tupItem{hijoIzq}{puntero(Nodo)}
			\tupItem{hijoDer}{puntero(Nodo)}				
			\tupItem{id}{jugador}
			\tupItem{cantPokemons}{nat}
			\tupItem{alto}{nat}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación}

	\begin{enumerate}
		
		\item No hay jugadores repetidos

		\item Un nodo cualquiera del arbol de jugadores su hijo izquierdo tiene menor id y su hijo derecho tiene mayor id

		\item Un nodo cualquiera del arbol de cantidades su hijo izquierdo tiene menor o igual cantidad y su hijo derecho tiene mayor o igual cantidad

		\item Un nodo cualquiera del arbol de cantidades su hijo izquierdo si tiene la misma cantidad tiene menor id y lo mismo para su hijo derecho pero mayor id

		\item La altura de un Nodo es la altura del hijo con mayor altura mas 1

		\item El factor de balanceo es $\leq$ 1 (donde el factor de balanceo es el modulo de la diferencia de las alturas de los hijos)

		\item Los arboles tienen los mismos elementos

	\end{enumerate}
	

	\Rep[ePrior][e]{
		sinRepetidos(e.raizJugadores, $\emptyset$) $\land$\\
		sinRepetidos(e.raizCantidad, $\emptyset$) $\land$\\
		ABB?(e.raizJugadores) $\land$\\
		altoValido?(e.raizJugadores) $\land$\\
		ABB?(e.raizCantidad) $\land$\\
		altoValido?(e.raizCantidad) $\land$\\
		($\forall$ j: jugador) (definido?(j, e.raizJugadores) = definido?(j, e.raizCantidad) $\yluego$ \\
			definido?(j, e.raizJugadores) $\impluego$ obtener(j, e.raizJugadores) = obtener(j, e.raizCantidad))
	}

	\TituloDis{Función de Abstracción}

	\Abs[ePrior]{prior}[e]{d}
	{($\forall j$: jugador)
	(def?(j, d) = definido?(j, e.raizJugadores) $\yluego$ \\
	(def?(j, d) $\impluego$ obtener(j, d) = obtener(j, e.raizJugadores)))
	}

	\TituloDis{Operaciones auxiliares}

	\tadOperacion{sinRepetidos}{puntero(nodo), conj(nat)}{bool}{}
	\tadOperacion{ABB?}{puntero(Nodo)/nodo}{bool}{}
	\tadOperacion{menor?}{puntero(Nodo)/padre, puntero(Nodo)/hijo}{bool}{padre $\neq$ NULL}
	\tadOperacion{ABBespecial?}{puntero(Nodo)/nodo}{bool}{}
	\tadOperacion{menorEspecial?}{puntero(Nodo)/padre, puntero(Nodo)/hijo}{bool}{padre $\neq$ NULL}
	\tadOperacion{altoValido?}(puntero(nodo)){bool}{}
	\tadOperacion{mayorAltura}{nat, nat}{nat}{}
	\tadOperacion{factorDeBalanceo}{nat, nat}{nat}{}
	\tadOperacion{cantidadHijos}{puntero(Nodo)}{nat}{}
	\tadOperacion{definido?}{jugador, puntero(nodo)}{bool}{}
	\tadOperacion{obtener}{jugador/j, puntero(nodo)/p}{nat}{definido?(j,p)}

 	~

	\tadAxioma{sinRepetidos(padre, ids)}{
		padre $\neq$ NULL $\oluego$( padre.id $\not\in$ ids $\land$ \\
		sinRepetidos(padre.hijoIzq, Ag(padre.id, c)) $\land$ \\
		sinRepetidos(padre.hijoDer, Ag(padre.id, c)))
	}

	~

	\tadAxioma{ABB?(nodo)}{
		(nodo = NULL) $\oluego$ \\ 
		(menor?(nodo, nodo.hijoIzq) $\land$ $\neq$menor?(nodo, nodo.hijoDer) $\land$ \\
		ABB?(nodo.hijoIzq) $\land$ ABB?(nodo.hijoDer))
	}

	~

	\tadAxioma{ABBespecial?(nodo)}{
		(nodo = NULL) $\oluego$ \\ 
		(menorEspecial?(nodo, nodo.hijoIzq) $\land$ $\neq$menorEspecial?(nodo, nodo.hijoDer) $\land$ \\
		ABBespecial?(nodo.hijoIzq) $\land$ ABBespecial?(nodo.hijoDer))
	}

	~

	\tadAxioma{menor?(padre, hijo)}{
		(hijo = NULL) $\oluego$ 
		padre.id $<$ hijo.id)
	}

	~

	\tadAxioma{menorEspecial?(padre, hijo)}{
		(hijo = NULL) $\oluego$ padre.cantPokemons $<$ hijo.cantPokemons $\lor$ \\
		(padre.cantPokemons = hijo.cantPokemons $\land$ padre.id $<$ hijo.id)
	}

	~

	\tadAxioma{altoValido?(nodo)}{
		nodo = NULL $\oluego$ \\
		(nodo.alto = mayorAltura(nodo.hijoIzq, nodo.hijoDer) + 1 $\land$ \\
		factorDeBalanceo(cantidadHijos(nodo.hijoIzq), cantidadHijos(nodo.hijoDer)) $\leq$ 1 
	}

	~

	\tadAxioma{mayorAltura(izq, der)}{
		{\IF cantidadHijos(izq) $<$ cantidadHijos(der) THEN
			cantidadHijos(izq)
		ELSE
			cantidadHijos(der)
		FI}
	}

	~

	\tadAxioma{cantidadHijos(nodo)}{
		{\IF nodo = NULL THEN
			0
		ELSE
			$\beta$(nodo.hijoIzq $\neq$ NULL) + cantidadHijos(nodo.hijoIzq) + \\
			$\beta$(nodo.hijoDer $\neq$ NULL) + cantidadHijos(nodo.hijoDer)		
		FI}
	}

	~

	\tadAxioma{factorDeBalanceo(izq, der)}{
		{\IF izq $<$ der THEN
			der - izq 
		ELSE
			izq - der
		FI}
	}

	~

	\tadAxioma{definido?(j , p)}{
		p $\neq$ NULL $\yluego$ (p.id = j $\lor$ definido?(j, p.hijoIzq) $\lor$ definido?(j, p.hijoDer))
	}

	~

	\tadAxioma{obtener(j , p)}{
		{\IF p.id = j THEN
			p.cantPokemons
		ELSE
			{\IF definido?(j, p.hijoIzq) THEN
				obtener(j, p.hijoIzq)
			ELSE
				obtener(j, p.hijoDer)
			FI}
		FI}
	}


\end{Representacion}

\begin{Algoritmos}
	\TituloDis{Algorítmos de Diccionario de Prioridad de atrape}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacio}{}{prior}}
		res.raizJugadores $\leftarrow$ NULL\;
		res.raizCantidad $\leftarrow$ NULL\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDefinido?}{\In{p}{prior}, \In{j}{jugador}}{bool}}
		res $\leftarrow$ BuscarJ(p.raizJugadores) $\neq$ NULL\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDefinir}{\Inout{p}{prior}, \In{j}{jugador}, \In{n}{nat}}{}}
		\If{Definido?(p, j)}{
			Borrar(p, j)\;
		}
		InsertarJ(j, n, p.raizJugadores)\;
		InsertarN(j, n, p.raizCantidad)\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iBorrar}{\Inout{p}{prior}, \In{j}{jugador}}{}}
		puntero(Nodo): nodo $\leftarrow$ BuscarJ(j, p.raizJugadores)\;
		RemoverJ(j, p.raizJugadores)\;
		RemoverN(j, nodo.cantPokemons, p.raizCantidad)\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iClaves}{\In{p}{prior}}{conj(string)}}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iMenor}{\In{p}{prior}}{jugador}}
		puntero(Nodo): nodo $\leftarrow$ BuscarMinimo(j, p.raizCantidad)\;
		res $\leftarrow$ nodo.id\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarJ}{\In{j}{jugador}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\eIf{nodo = NULL $\oluego$ nodo.id = jugador}{
			res $\leftarrow$ nodo\;
		}{
			\eIf{j $<$ nodo.id}{
				res $\leftarrow$ BuscarJ(j, nodo.hijoIzq)\;
			}{
				res $\leftarrow$ BuscarJ(j, nodo.hijoDer)\;
			}
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{InsertarJ}{\In{j}{jugador}, \In{n}{nat}, \Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\eIf{nodo = NULL}{
			res $\leftarrow$ CrearNodo(j, n)\;
		}{	
			\eIf{j $<$ n.id}{
				nodo.hijoIzq $\leftarrow$ InsertarJ(j, n, nodo.hijoIzq)\;
			}{
				nodo.hijoDer $\leftarrow$ InsertarJ(j, n, nodo.hijoDer)\;
			}
			res $\leftarrow$ Balancear(nodo)\;
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverJ}{\In{j}{jugador}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\eIf{nodo = NULL}{
			res $\leftarrow$ nodo\;
		}{
			\eIf{j $<$ nodo.id}{
				nodo.hijoIzq $\leftarrow$ RemoverJ(j, nodo.hijoIzq)\;
				res $\leftarrow$ Balancear(nodo)\;
			}{
				\eIf{j $>$ nodo.id}{
					nodo.hijoDer $\leftarrow$ RemoverJ(j, nodo.hijoDer)\;
					res $\leftarrow$ Balancear(nodo)\;
				}{
					puntero(Nodo): i $\leftarrow$ nodo.hijoIzq\;
					puntero(Nodo): d $\leftarrow$ nodo.hijoDer\;
					delete nodo\;
					\eIf{ d = NULL}{
						res $\leftarrow$ i\;
					}{	
						puntero(Nodo): minimo $\leftarrow$ BuscarMinimo(d)\;
						minimo.hijoDer $\leftarrow$ RemoverMinimo(d)\;
						minimo.hijoIzq $\leftarrow$ i\;
						res $\leftarrow$ Balancear(minimo)\;
					}
				}
			}
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\eIf{nodo.hijoIzq = NULL}{
			res $\leftarrow$ nodo\;
		}{
			res $\leftarrow$ BuscarMinimo(nodo.hijoIzq)\;
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\eIf{nodo.hijoIzq = NULL}{
			res $\leftarrow$ nodo.hijoDer\;
		}{
			nodo.hijoIzq = RemoverMinimo(nodo.hijoIzq)\;
			res $\leftarrow$ balance(nodo)\;
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarN}{\In{j}{jugador}, \In{n}{nat} \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\eIf{nodo = NULL $\oluego$ (nodo.id = jugador $\land$ nodo.cantPokemons = n)}{
			res $\leftarrow$ nodo\;
		}{
			\eIf{n $<$ nodo.cantPokemons $\lor$ (n = nodo.cantPokemons $\land$ j $<$ nodo.id)}{
				res $\leftarrow$ BuscarN(j, n, nodo.hijoIzq)\;
			}{
				res $\leftarrow$ BuscarN(j, n, nodo.hijoDer)\;
			}
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{InsertarN}{\In{j}{jugador}, \In{n}{nat}, \Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\eIf{nodo = NULL}{
			res $\leftarrow$ CrearNodo(j, n)\;
		}{	
			\eIf{n $<$ nodo.cantPokemons $\lor$ (n = nodo.cantPokemons $\land$ j $<$ nodo.id)}{
				nodo.hijoIzq $\leftarrow$ InsertarN(j, n, nodo.hijoIzq)\;
			}{
				nodo.hijoDer $\leftarrow$ InsertarN(j, n, nodo.hijoDer)\;
			}
			res $\leftarrow$ Balancear(nodo)\;
		}
	\end{algorithm}


	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearNodo}{\In{j}{jugador}, \In{n}{nat}}{puntero(Nodo)}}
		Nodo: nuevo\;
		nuevo.hijoIzq $\leftarrow$ NULL\;
		nuevo.hijoDer $\leftarrow$ NULL\;
		nuevo.alto $\leftarrow$ 1\;
		nuevo.id $\leftarrow$ j\;
		nuevo.cantPokemons $\leftarrow$ n\;
		res $\leftarrow$ \&nuevo\;
	\end{algorithm}


	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Balancear}{\Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		ArreglarAlto(nodo)\;
		\eIf{FactorDeBalance(nodo) = 2}{
			\If{FactorDeBalance(nodo.hijoDer) $<$ 0}{
				nodo.hijoDer $\leftarrow$ rotarDer(nodo.hijoDer);
			}
			res $\leftarrow$ rotarIzq(nodo)\;
		}{
			\eIf{FactorDeBalance(nodo) = -2}{
				\If{FactorDeBalance(nodo.hijoDer) $>$ 0}{
					nodo.hijoIzq $\leftarrow$ rotarIzq(nodo.hijoIzq);
				}
				res $\leftarrow$ rotarDer(nodo)\;
			}{
				res $\leftarrow$ nodo\;
			}
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{ArreglarAlto}{\Inout{nodo}{puntero(Nodo)}}{}}
		nat: alturaIzq $\leftarrow$ Altura(p.hijoIzq)\;
		nat: alturaDer $\leftarrow$ Altura(p.hijoDer)\;
		\eIf{alturaIzq $<$ alturaDer}{
			nodo.altura $\leftarrow$  alturaDer + 1\;
		}{
			nodo.altura $\leftarrow$  alturaIzq + 1\;
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Altura}{\In{nodo}{puntero(Nodo)}}{nat}}
		\eIf{nodo = NULL}{
			res $\leftarrow$ 0\;
		}{
			res $\leftarrow$ nodo.alto\;
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{FactorDeBalance}{\In{nodo}{puntero(Nodo)}}{nat}}
		res $\leftarrow$ Altura(nodo.hijoDer) - Altura(nodo.hijoIzq)\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarDer}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		puntero(nodo) aux $\leftarrow$ nodo.hijoIzq\;
		nodo.hijoIzq $\leftarrow$ aux.hijoDer\;
		aux.hijoDer $\leftarrow$ nodo\;
		ArreglarAlto(nodo)\;
		ArreglarAlto(aux)\;
		res $\leftarrow$ aux\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarIzq}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		puntero(nodo) aux $\leftarrow$ nodo.hijoDer\;
		nodo.hijoDer $\leftarrow$ aux.hijoIzq\;
		aux.hijoIzq $\leftarrow$ nodo\;
		ArreglarAlto(nodo)\;
		ArreglarAlto(aux)\;
		res $\leftarrow$ aux\;
	\end{algorithm}

\end{Algoritmos}