\section{Módulo Diccionario de Prioridad de atrape}
	Description %%TODO 

\begin{Interfaz}
	\textbf{se explica con}: \tadNombre{Diccionario(Jugador, Nat)}. 

	\textbf{géneros}: \TipoVariable{prior}.

	\TituloDis{Operaciones básicas de Diccionario de Prioridad de atrape}

	\InterfazFuncion{Vacio}{}{prior}
	[]
	{res $\igob$ vacío}
	[$O(1)$]]
	[Crea el diccionario vacío]

	\InterfazFuncion{Definir}{\Inout{p}{prior}, \In{j}{jugador}, \In{c}{nat}}{}
	[$p \igobs p_0$]
	{$p \igobs$ definir($j, c, p_0$)}
	[$log(\#j)$]
	[define la cantidad de pokemons de un jugador en el diccionario.]
	[se almacenan copias de $j$ y $c$.]

	\InterfazFuncion{Definido?}{\In{p}{prior}, \In{j}{jugador}}{bool}
	{$res \igobs$ def?($j, p$)]}
	[$log(\#j)$]
	[devuelve \texttt{true} si el jugador esta definido en el diccionario.]

	\InterfazFuncion{Obtener}{\In{p}{prior}, \In{j}{jugador}}{nat}
	[def?($j, p$)]
	{alias($res \igobs$ obtener($j$, $p$))}
	[$log(\#j)$]
	[devuelve la cantidad de pokemons de un jugador en el diccionario.]
	[$res$ es modificable si y sólo si $p$ es modificable.]

	\InterfazFuncion{Borrar}{\Inout{p}{prior}, \In{j}{jugador}}{}
	[$p \igobs p_0 \land$ def?($j, d_0$)]
	{$p \igobs$ borrar($j, p_0$)}
	[$log(\#j)$]
	[borra un jugador del diccionario.]

	\InterfazFuncion{Claves}{\In{p}{prior}}{conj(string)}
	{alias($res =$ claves($p$))}
	[]%O de N
	[devuelve el conjunto de los jugadores del diccionario.]
	[$res$ no es modificable.]

	\InterfazFuncion{Menor}{\Inout{p}{prior}}{jugador}
	[$\neg\emptyset$?(claves($p$))]
	{$res \igobs$ menor($p$, claves($p$))}
	[$log(\#j)$]
	[devuelve el jugador con menos pokemons en el diccionario]
	[]

  \Titulo{Especificación de las operaciones auxiliares utilizadas en la interfaz}

  \begin{tad}{Diccionario(Jugador, Nat) Extendido}
    \parskip=0pt
    \tadExtiende{\tadNombre{Diccionario(Jugador, Nat)}}
    
    \tadTitulo{otras operaciones (exportadas)}
    \tadOperacion{menor}{dicc(nat, nat)/d, conj(nat)/c}{nat}{$\neg\emptyset$?(c) $\land$ c $\subseteq$ claves(d)}
    \tadAxiomas
    \tadAxioma{menor(d,c)}{\IF $\emptyset$?(dameUno(c)) THEN 
    	sinUno(c) 
    ELSE 
    	{\IF obtener(dameUno(c), d) $<$ menor(d, sinUno(c)) THEN
    		dameUno(c)
    	ELSE
    		menor(d, sinUno(c))
    	FI}
    FI}
  \end{tad}

\end{Interfaz}


\begin{Representacion}
	\TituloDis{Representación de prior}

	\begin{Estructura}{ prior }[ePrior]
		\begin{Tupla}[ePrior]
			\tupItem{raizJugadores}{puntero(Nodo)}
			\tupItem{raizCantidad}{puntero(Nodo)}
		\end{Tupla}
		\begin{Tupla}[Nodo]
			\tupItem{hijoIzq}{puntero(Nodo)}
			\tupItem{hijoDer}{puntero(Nodo)}				
			\tupItem{id}{jugador}
			\tupItem{cantPokemons}{nat}
			\tupItem{alto}{nat}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación}

	\begin{enumerate}
		
		\item No hay jugadores repetidos

		\item Un nodo cualquiera del arbol de jugadores su hijo izquierdo tiene menor id y su hijo derecho tiene mayor id

		\item Un nodo cualquiera del arbol de cantidades su hijo izquierdo tiene menor o igual cantidad y su hijo derecho tiene mayor o igual cantidad

		\item Un nodo cualquiera del arbol de cantidades su hijo izquierdo si tiene la misma cantidad tiene menor id y lo mismo para su hijo derecho pero mayor id

		\item La altura de un Nodo es la altura del hijo con mayor altura mas 1

		\item El factor de balanceo es $\leq$ 1 (donde el factor de balanceo es el modulo de la diferencia de las alturas de los hijos)

		\item Los arboles tienen los mismos elementos

	\end{enumerate}
	

	\Rep[ePrior][e]{
		sinRepetidos(e.raizJugadores, $\emptyset$) $\land$ ABB?(e.raizJugadores) $\land$ altoValido?(e.raizJugadores) $\land$ \\
		sinRepetidos(e.raizCantidad, $\emptyset$) $\land$ ABB?(e.raizCantidad) $\land$ altoValido?(e.raizCantidad) $\land$ \\
		($\forall$ j: jugador) (definido?(j, e.raizJugadores) = definido?(j, e.raizCantidad) $\yluego$ \\
			definido?(j, e.raizJugadores) $\impluego$ obtener(j, e.raizJugadores) = obtener(j, e.raizCantidad))
	}

	\tadOperacion{sinRepetidos}{puntero(nodo), conj(nat)}{}
	\tadOperacion{ABB?}{puntero(Nodo)/nodo}{bool}{}
	\tadOperacion{menor?}{puntero(Nodo)/padre, puntero(Nodo)/hijo}{bool}{padre $\neq$ NULL}
	\tadOperacion{ABBespecial?}{puntero(Nodo)/nodo}{bool}{}
	\tadOperacion{menorEspecial?}{puntero(Nodo)/padre, puntero(Nodo)/hijo}{bool}{padre $\neq$ NULL}
	\tadOperacion{altoValido?}(puntero(nodo)){bool}{}
	\tadOperacion{mayorAltura}{nat, nat}{nat}{}
	\tadOperacion{factorDeBalanceo}{nat, nat}{nat}{}
	\tadOperacion{cantidadHijos}{puntero(Nodo)}{}
	\tadOperacion{definido?}{jugador, puntero(nodo)}{}
	\tadOperacion{obtener}{jugador/j, puntero(nodo)/p}{definido?(j,p)}
 	~

	\tadAxioma{sinRepetidos(padre, ids)}{
		padre $\neq$ NULL $\oluego$( padre.id $\not\in$ ids $\land$ \\
		sinRepetidos(padre.hijoIzq, Ag(padre.id, c)) $\land$ \\
		sinRepetidos(padre.hijoDer, Ag(padre.id, c)))
	}

	~

	\tadAxioma{ABB?(nodo)}{
		(nodo = NULL) $\oluego$ \\ 
		(menor?(nodo, nodo.hijoIzq) $\land$ $\neq$menor?(nodo, nodo.hijoDer) $\land$ \\
		ABB?(nodo.hijoIzq) $\land$ ABB?(nodo.hijoDer))
	}

	~

	\tadAxioma{ABBespecial?(nodo)}{
		(nodo = NULL) $\oluego$ \\ 
		(menorEspecial?(nodo, nodo.hijoIzq) $\land$ $\neq$menorEspecial?(nodo, nodo.hijoDer) $\land$ \\
		ABBespecial?(nodo.hijoIzq) $\land$ ABBespecial?(nodo.hijoDer))
	}

	~

	\tadAxioma{menor?(padre, hijo)}{
		(hijo = NULL) $\oluego$ 
		padre.id $<$ hijo.id)
	}

	~

	\tadAxioma{menorEspecial?(padre, hijo)}{
		(hijo = NULL) $\oluego$ padre.cantPokemons $<$ hijo.cantPokemons $\lor$ \\
		(padre.cantPokemons = hijo.cantPokemons $\land$ padre.id $<$ hijo.id)
	}

	~

	\tadAxioma{altoValido?(nodo)}{
		nodo = NULL $\oluego$ \\
		(nodo.alto = mayorAltura(nodo.hijoIzq, nodo.hijoDer) + 1 $\land$ \\
		factorDeBalanceo(cantidadHijos(nodo.hijoIzq), cantidadHijos(nodo.hijoDer)) $\leq$ 1 
	}

	~

	\tadAxioma{mayorAltura(izq, der)}{
		{\IF cantidadHijos(izq) $<$ cantidadHijos(der) THEN
			cantidadHijos(izq)
		ELSE
			cantidadHijos(der)
		FI}
	}

	~

	\tadAxioma{cantidadHijos(nodo)}{
		{\IF nodo = NULL THEN
			0
		ELSE
			$\beta$(nodo.hijoIzq $\neq$ NULL) + cantidadHijos(nodo.hijoIzq) + \\
			$\beta$(nodo.hijoDer $\neq$ NULL) + cantidadHijos(nodo.hijoDer)		
		FI}
	}

	~

	\tadAxioma{factorDeBalanceo(izq, der)}{
		{\IF izq $<$ der THEN
			der - izq 
		ELSE
			izq - der
		FI}
	}

	~

	\tadAxioma{definido?(j , p)}{
		p $\neq$ NULL $\yluego$ (p.id = j $\lor$ definido?(j, p.hijoIzq) $\lor$ definido?(j, p.hijoDer))
	}

	~

	\tadAxioma{obtener(j , p)}{
		{\IF p.id = j THEN
			p.cantPokemons
		ELSE
			{\IF definido?(j, p.hijoIzq) THEN
				obtener(j, p.hijoIzq)
			ELSE
				obtener(j, p.hijoDer)
			FI}
		FI}
	}

	\TituloDis{Función de Abstracción}


	\Abs[ePrior]{prior}[e]{d}
	{($\forall j$: jugador)
	(def?(j, d) = definido?(j, e.raizJugadores) $\yluego$ \\
	(def?(j, d) $\impluego$ obtener(j, d) = obtener(j, e.raizJugadores)))
	}


\end{Representacion}

\begin{Algoritmos}
	\TituloDis{Algorítmos de Diccionario de Prioridad de atrape}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacia}{}{prior}}
		res.raiz $\leftarrow$ NULL\;
	\end{algorithm}


	% \begin{algorithm}[H]
	% 	\NoCaptionOfAlgo
	% 	\caption{\algoritmo{Buscar}{\In{a}{RELLENAR}, \Inout{hijo}{puntero(Nodo)}}}
	% 	\While{hijo $\neq$ NULL $\yluego$ hijo.id $\neq$ a}{
	% 		\eIf{hijo.cant $<$ a.cant $\lor$ (hijo.cant = a.cant $\land$ hijo.id $<$ a.id}{
	% 			hijo $\leftarrow$ hijo.hijoIzq\;
	% 		}{
	% 			hijo $\leftarrow$ hijo.hijoDer\;
	% 		}
	% 	}
	% \end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iAgregar}{\In{a}{RELLENAR}, \Inout{h}{prior}}{}}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearNodo}{\In{a}{RELLNAR}}{puntero(Nodo)}}
		Nodo: nuevo\;
		nuevo.valor $\leftarrow$ a\; %%TODO CAMBIAR
		nuevo.hijoIzq $\leftarrow$ NULL\;
		nuevo.hijoDer $\leftarrow$ NULL\;
		nuevo.alto $\leftarrow$ 1\;
		res $\leftarrow$ \&nuevo\;
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Insertar}{\In{a}{RELLENAR}, \Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		
		\eIf{nodo = NULL}{
			res $\leftarrow$ CrearNodo(a)\;
		}{	
			%%TODO hacer bien la comapracion
			\eIf{n.valor $<$ a}{
				nodo.hijoIzq $\leftarrow$ Insertar(a, nodo.hijoIzq)\;
			}{
				nodo.hijoDer $\leftarrow$ Insertar(a, nodo.hijoDer)\;
			}
			res $\leftarrow$ Balancear(nodo)\;
		}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Balancear}{\Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		%%TODO ArreglarFactor(nodo)
		\eIf(FactorDeBalanceo(nodo) = 2){
			\If(FactorDeBalanceo(nodo.hijoDer) $<$ 0){
				nodo.hijoDer $\leftarrow$ rotarDer(nodo.hijoDer);
			}
			res $\leftarrow$ rotarIzq(nodo)\;
		}{
			\eIf(FactorDeBalanceo(nodo) = -2){
				\If(FactorDeBalanceo(nodo.hijoDer) $>$ 0){
					nodo.hijoIzq $\leftarrow$ rotarIzq(nodo.hijoIzq);
				}
				res $\leftarrow$ rotarDer(nodo)\;
			}{
				res $\leftarrow$ nodo\;
			}
		}
	\end{algorithm}


	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacia?}{\In{h}{prior}}{bool}}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPertenece?}{\In{a}{RELLENAR}, \In{h}{prior}}{bool}}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iBorrar}{\In{a}{RELLENAR}, \Inout{h}{prior}}{}}
	\end{algorithm}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iMenor}{\In{a}{RELLENAR}, \Inout{h}{prior}}{RELLENAR}}
	\end{algorithm}


\end{Algoritmos}