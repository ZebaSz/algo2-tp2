\section{Módulo ConjuntoOrd($\alpha$)}

Este conjunto aprovecha el orden absoluto de los jugadores (nats) para almacenar los datos en un arbol de búsqueda autobalanceado (AVL). Esto permite agregar, buscar y remover cualquier elemento en tiempo logarítmico.

Usaremos $\#c$ para denotar la cantidad de entradas del diccionario.

\begin{Interfaz}
	\textbf{se explica con}: \tadNombre{Conjunto($\alpha$)}, \tadNombre{Iterador Unidireccional(Jugador)}.

	\textbf{géneros}: \TipoVariable{conjOrd}, \TipoVariable{itConjOrd}.

	\TituloDis{Operaciones básicas de ConjuntoOrd($\alpha$)}

	\InterfazFuncion{Vacio}{}{conjOrd}
	{res $\igobs \emptyset$ }
	[$O(1)$]
	[Crea el conjunto vacío]

	\InterfazFuncion{Agregar}{\Inout{c}{conjOrd}, \In{a}{$\alpha$}}{}
	[$c \igobs c_0$]
	{$c \igobs$ Ag($j, c_0$)}
	[$O(log(\#c))$]
	[Agrega al conjunto j]
	[se almacenan copias de $j$.]

	\InterfazFuncion{Pertenece?}{\In{c}{conjOrd}, \In{a}{$\alpha$}}{bool}
	{$res \igobs$ $j \in c$)]}
	[$O(log(\#c))$]
	[devuelve \texttt{true} si el jugador esta en el conjunto.]

	\InterfazFuncion{Borrar}{\Inout{c}{conjOrd}, \In{a}{$\alpha$}}{}
	[$c \igobs c_0$)]
	{$c \igobs$ borrar($j, c_0$)}
	[$O(log(\#c))$]
	[borra un jugador del conjunto.]


	\TituloDis{Operaciones básicas del iterador}

	El iterador que presentamos no permite modificar el conjunto recorrido.


	\InterfazFuncion{CrearIt}{\In{c}{conjOrd}}{itConjOrd}
	{true}
	[$O(1)$]
	[crea un iterador unidireccional de los jugadores validos o expulsados.]
	[el iterador se invalida si y solo si se elimina el siguiente elemento del iterador. Además, siguientes($res$) podría cambiar completamente ante cualquier operación que modifique el conjunto.]

	\InterfazFuncion{HayMas}{\In{it}{itConjOrd}}{bool}
	{$res$ $\igobs$ hayMas?($it$)}
	[$O(1)$]
	[devuelve \texttt{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

	\InterfazFuncion{Actual}{\In{it}{itConjOrd}}{jugador}
	[HayMas?($it$)]
	{$res$ $\igobs$ Actual($it$)}
	[$O(1))$]
	[devuelve el elemento siguiente a la posición del iterador.]

	\InterfazFuncion{Avanzar}{\Inout{it}{itConjOrd}}{}
	[$it = it_0$ $\land$ HayMas?($it$)]
	{$it$ $\igobs$ Avanzar($it_0$)}
	[$O(log(\#c))$]
	[avanza a la posición siguiente del iterador.]

\end{Interfaz}


\begin{Representacion}
	\TituloDis{Representación de conjOrd}

	\begin{Estructura}{conjOrd}[eConj]
		\begin{Tupla}[eConj]
			\tupItem{TODO}{TODO ACA VA EL DICCIONARIO}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación de ConjuntoOrd($\alpha$)}

	\begin{enumerate}

	

	\end{enumerate}
	
	\Rep[eConj][e]{}
	%%TODO FiJARSE SI ESTA EL TRUE SI NO PONERLO

	\TituloDis{Función de Abstracción}

	\Abs[eConj]{conjOrd}[e]{d}
	{($\forall a$: $\alpha$) a $\in$ d = definido?(a, e.raiz)}
	%%TODO cambiar e.raiz

	\TituloDis{Representación del iterador}

	\begin{Estructura}{itConjOrd}[itJugs]
		\begin{Tupla}[itJugs]
			\tupItem{conjunto}{puntero(conjOrd)}
			\tupItem{pila}{pila(puntero(Nodo))}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación del iterador}

	\begin{enumerate}

		\item El conjunto no es nulo

		\item Ningún elemento de la pila es nulo

		\item Todo elemento de la pila es menor al anterior

	\end{enumerate}

	\Rep[itJugs][it]{it.conjunto $\neq$ NULL $\land$ PilaValida?(it.pila)}


	\TituloDis{Función de Abstracción del iterador}

	\Abs[itJugs]{itUni(nat)}[it]{b}{Siguientes(b) $=$ Sigs(it.pila)}

	\tadOperacion{PilaValida?}{pila(puntero(Nodo))}{bool}{}
	\tadOperacion{Sigs}{pila(puntero(Nodo))}{secu(jugador)}{}
	\tadOperacion{Hijos}{puntero(Nodo)/n}{secu(jugador)}{n $\neq$ NULL}
	\tadOperacion{HijosDer}{pila(puntero(Nodo))/p}{secu(jugador)}{}

	~
	\tadAxioma{PilaValida?(p)}{
	vacia?(p) $\oluego$ (PilaValida?(desapilar(p)) $\land$ tope(p) $\neq$ NULL $\yluego$ \\
	(vacia?(desapilar(p)) $\oluego$ (*tope(p)).id $<$ (*tope(desapilar(p))).id))}

	~

	\tadAxioma{Sigs(p)}{
	\IF vacia?(p) THEN
		\secuvacia
	ELSE
		Hijos(tope(p)) \& HijosDer(desapilar(p))
	FI}


	\tadAxioma{Hijos(n)}{
	\IF n = NULL THEN
		\secuvacia
	ELSE
		(*n).id \puntito (Hijos((*n).hijoIzq) \& Hijos((*n).hijoDer))
	FI}

	~

	\tadAxioma{HijosDer(n)}{
	\IF vacia?(p) THEN
		\secuvacia
	ELSE
		Hijos((*tope(p)).hijoDer) \& HijosDer(desapilar(p))
	FI}


\end{Representacion}

\begin{Algoritmos}
	\TituloDis{Algoritmos de ConjuntoOrd($\alpha$)}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacio}{}{eConj}}
		res.raiz $\leftarrow$ NULL\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializan los punteros como nulos.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPertenece?}{\In{c}{eConj}, \In{a}{$\alpha$}}{bool}}
		res $\leftarrow$ Definido?(c.raiz, a) \OdeLinea{log(\#c)}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iAgregar}{\Inout{c}{eConj}, \In{a}{$\alpha$}}{}}
		p.raiz $\leftarrow$ Definir(e.raiz, a, true)\OdeLinea{log(\#c)}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iBorrar}{\Inout{c}{eConj}, \In{a}{$\alpha$}}{}}
		p.raiz $\leftarrow$ Remover(j, p.raiz)\OdeLinea{log(\#c)}
	\end{algorithm}

	\complejidad: $O(log(\#c))$

	\justifcomp: la complejidad de buscar, agregar o eliminar un elemento es de orden de la altura del arbol, que por invariante de AVL sabemos que es $log(\#c)$


	\TituloDis{Algoritmos auxiliares}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Buscar}{\In{a}{$\alpha$}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{\texttt{true}}
		\Post{res es igual al nodo hijo o el que viene por parametro que tenga el id del jugador a menos que no este en cuyo caso en NULL}
		\BlankLine
		\uIf{nodo = NULL \textbf{or} (*nodo).id = jugador}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
		\uElseIf{j $<$ (*nodo).id}{
			res $\leftarrow$ Buscar(j, (*nodo).hijoIzq)\OdeLinea{h}
		}
		\Else{
			res $\leftarrow$ Buscar(j, (*nodo).hijoDer)\OdeLinea{h}
		}
	\end{algorithm}

	\complejidad: $O(h)$ 


	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Insertar}{\In{a}{$\alpha$}, \Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{\texttt{true}}
		\Post{res es igual a la raiz del subarbol del nodo pasado por parámetro pero con el nuevo elemento y balanceado}
		\BlankLine
		\eIf{nodo = NULL}{
			res $\leftarrow$ CrearNodo(j)\OdeLinea{1}
		}{	
			\eIf{j = nodo.id}{
				res $\leftarrow$ nodo\OdeLinea{1}
			}{	
				\eIf{j $<$ nodo.id}{
					(*nodo).hijoIzq $\leftarrow$ Insertar(j, (*nodo).hijoIzq)\OdeLinea{h}
				}{
					(*nodo).hijoDer $\leftarrow$ Insertar(j, (*nodo).hijoDer)\OdeLinea{h}
				}
				res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
			}

		}
	\end{algorithm}

	\complejidad: $O(h)$ 

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Remover}{\In{a}{$\alpha$}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{entre los nodo que desprenden del nodo del parametro se encuentra el id j.} 
		\Post{res es el mismo nodo pero ahora con el hijo removido en esa rama excepto que sea el nodo que hay que remover el cual se convierte en null}
		\BlankLine
		\uIf{nodo = NULL}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
		\uElseIf{j $<$ (*nodo).id}{
			(*nodo).hijoIzq $\leftarrow$ Remover(j, (*nodo).hijoIzq)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\uElseIf{j $>$ (*nodo).id}{
			(*nodo).hijoDer $\leftarrow$ Remover(j, (*nodo).hijoDer)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
		\Else{
			puntero(Nodo): i $\leftarrow$ (*nodo).hijoIzq\OdeLinea{1}
			puntero(Nodo): d $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
			\eIf{d = NULL}{
				res $\leftarrow$ i\OdeLinea{1}
			}{
				puntero(Nodo): minimo $\leftarrow$ BuscarMinimo(d)\OdeLinea{h}
				minimo.hijoDer $\leftarrow$ RemoverMinimo(d)\OdeLinea{h}
				minimo.hijoIzq $\leftarrow$ i\OdeLinea{1}
				res $\leftarrow$ Balancear(minimo)\OdeLinea{1}
			}
		}
	\end{algorithm}

	\complejidad: $O(h)$ 
	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{true} 
		\Post{res es el puntero al minimo hijo del nodo(o el si es el menor)}
		\BlankLine
		\eIf{(*nodo).hijoIzq = NULL}{
			res $\leftarrow$ nodo\OdeLinea{1}
		}{
			res $\leftarrow$ BuscarMinimo((*nodo).hijoIzq)\OdeLinea{h}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverMinimo}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{true} 
		\Post{res es el el mismo nodo pero con el nodo de mas a la izquierda eliminado(al padre del menor, se le pasan los hijos mayores si es que tiene)}
		\BlankLine
		\eIf{(*nodo).hijoIzq = NULL}{
			res $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
		}{
			(*nodo).hijoIzq = RemoverMinimo((*nodo).hijoIzq)\OdeLinea{h}
			res $\leftarrow$ Balancear(nodo)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(h)$, donde $h$ es la altura del nodo

	\justifcomp: como sabemos la altura de un nodo es la mayor altura entre sus hijos + 1, como en cada iteración estamos haciendo una llamada recursiva a uno de sus hijos hasta que ese hijo sea nulo, en el peor de los casos llamamos recursivamente al hijo con mayor altura y en cada llamada estamos disminuyendo en 1 la altura.

	La complejidad es equivalente a $log(n)$, donde $n$ es la cantidad de hijos del nodo, ya que al estar ordenado como ABB y balanceado con invariante de AVL, cada llamada recursiva a cada subarbol reduce el tamaño de la entrada aproximadamente por la mitad.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearNodo}{\In{a}{$\alpha$}}{puntero(Nodo)}}
		\Pre{\texttt{true}}
		\Post{$res$ apunta a un nodo de alto 1 con id $j$}
		\BlankLine
		Nodo: nuevo\OdeLinea{1}
		nuevo.hijoIzq $\leftarrow$ NULL\OdeLinea{1}
		nuevo.hijoDer $\leftarrow$ NULL\OdeLinea{1}
		nuevo.alto $\leftarrow$ 1\OdeLinea{1}
		nuevo.id $\leftarrow$ j\OdeLinea{1}
		res $\leftarrow$ \&nuevo\OdeLinea{1}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se crea e inicializa un (*nodo). Como inicialmente se agrega como hoja del arbol, su altura es 1.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{ArreglarAlto}{\Inout{nodo}{puntero(Nodo)}}{}}
		\Pre{$nodo \neq$ NULL}
		\Post{el módulo del factor de balanceo de $res$ es menor a 2}
		\BlankLine
		nat: alturaIzq $\leftarrow$ Altura((*nodo).hijoIzq)\OdeLinea{1}
		nat: alturaDer $\leftarrow$ Altura((*nodo).hijoDer)\OdeLinea{1}
		\eIf{alturaIzq $<$ alturaDer}{
			(*nodo).altura $\leftarrow$ alturaDer + 1\OdeLinea{1}
		}{
			(*nodo).altura $\leftarrow$ alturaIzq + 1\OdeLinea{1}
		}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se realizan comparaciones para las alturas de los hijos

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Altura}{\In{nodo}{puntero(Nodo)}}{nat}}
		\Pre{\texttt{true}}
		\Post{$res$ es 0 si $nodo$ es nulo, o igual a la altura del nodo al que apunta en caso contrario}
		\BlankLine
		\eIf{nodo = NULL}{
			res $\leftarrow$ 0\OdeLinea{1}
		}{
			res $\leftarrow$ (*nodo).alto\OdeLinea{1}
		}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: solo se verifica si es nulo o se lee un componente.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Balancear}{\Inout{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{$nodo \neq$ NULL}
		\Post{el módulo del factor de balanceo de $res$ es menor a 2}
		\BlankLine
		ArreglarAlto(nodo)\OdeLinea{1}
		nat: alturaIzq $\leftarrow$ Altura((*nodo).hijoIzq)\OdeLinea{1}
		nat: alturaDer $\leftarrow$ Altura((*nodo).hijoDer)\OdeLinea{1}
		\uIf{alturaDer $>$ alturaIzq \textbf{and} alturaDer - alturaIzq = 2}{
			\If{Altura((*nodo).hijoDer.hijoIzq) $>$ Altura((*nodo).hijoDer.hijoDer)}{
				(*nodo).hijoDer $\leftarrow$ rotarDer((*nodo).hijoDer\OdeLinea{1}
			}
			res $\leftarrow$ rotarIzq(nodo)\OdeLinea{1}
		}
		\uElseIf{alturaIzq $>$ alturaDer \textbf{and} alturaIzq - alturaDer = 2}{
			\If{Altura((*nodo).hijoIzq.hijoDer) $>$ Altura((*nodo).hijoIzq.hijoIzq)}{
				(*nodo).hijoIzq $\leftarrow$ rotarIzq((*nodo).hijoIzq)\OdeLinea{1}
			}
			res $\leftarrow$ rotarDer(nodo)\OdeLinea{1}
		}
		\Else{
			res $\leftarrow$ nodo\OdeLinea{1}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarDer}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{$nodo$ tiene un hijo izquierdo}
		\Post{$res$ es el hijo izquierdo de nodo, y arbol se rota a la derecha}
		\BlankLine
		puntero(nodo) : aux $\leftarrow$ (*nodo).hijoIzq\OdeLinea{1}
		(*nodo).hijoIzq $\leftarrow$ aux.hijoDer\OdeLinea{1}
		aux.hijoDer $\leftarrow$ nodo\OdeLinea{1}
		ArreglarAlto(nodo)\OdeLinea{1}
		ArreglarAlto(aux)\OdeLinea{1}
		res $\leftarrow$ aux\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{rotarIzq}{\In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{$nodo$ tiene un hijo derecho}
		\Post{$res$ es el hijo derecho de nodo, y arbol se rota a la izquierda}
		\BlankLine
		puntero(nodo) : aux $\leftarrow$ (*nodo).hijoDer\OdeLinea{1}
		(*nodo).hijoDer $\leftarrow$ aux.hijoIzq\OdeLinea{1}
		aux.hijoIzq $\leftarrow$ nodo\OdeLinea{1}
		ArreglarAlto(nodo)\OdeLinea{1}
		ArreglarAlto(aux)\OdeLinea{1}
		res $\leftarrow$ aux\OdeLinea{1}
	\end{algorithm}
	
	\complejidad: $O(1)$

	\justifcomp: las rotaciones son una serie de comparasiones y asignaciones de punteros ($\Theta(1)$). El invariante de orden del arbol de búsqueda (ABB) se preserva luego de cada rotación. El invariante de balanceo de AVL se restaura para cada subarbol al final de \texttt{Balancear}, pero no luego de cada rotación individual (puede ser necesario rotar un subarbol de manera temporalmente imbalanceada para restaurar el balance de un arbol).

	\TituloDis{Algoritmos del iterador}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearIt}{\In{c}{eConj}}{itJugs}}
		res.conjunto $\leftarrow$ \&(c)\OdeLinea{1}
		res.pila $\leftarrow$ Vacía()\OdeLinea{1}
		\If{\textbf{not} c.raiz = NULL}{
			Apilar(res.pila, c.raiz)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializa el iterador.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{HayMas}{\In{it}{itJugs}}{bool}}
		res $\leftarrow$ EsVacía?(it.pila)\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Actual}{\In{it}{itJugs}}{jugador}}
		res $\leftarrow$ (*Tope(it.pila)).id\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se utilizan operaciones básicas de pila.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Avanzar}{\Inout{it}{itJugs}}{}}
		\While(\OdeBloque{1}){\textbf{not} EsVacía(it.pila)} {
			puntero(Nodo) : tope $\leftarrow$ Tope(it.pila)\OdeLinea{1}
			\eIf{not (*tope).hijoIzq = NULL}{
				Apilar(it.pila, (*tope).hijoIzq)\OdeLinea{1}
					\textbf{break}\OdeLinea{1}
			}{
				Desapilar(it.pila)\OdeLinea{1}
				\If{not (*tope).hijoDer = NULL}{
					Apilar(it.pila, (*tope).hijoDer)\OdeLinea{1}
					\textbf{break}\OdeLinea{1}
				}
			}
		}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: la pila contiene aquellas posiciones para las cuales todavía no se visitó el nodo derecho, y en el caso del tope, tampoco se revisó el nodo izquierdo, además de estar ordenadas por posición en el arbol (las primeras que se agregan correpsonden a posiciones superiores).

	El peor caso posible para un ABB normal es que la pila contenga todos los elementos del conjunto (ningún nodo del arbol tiene nodo derecho).

	En el caso particular de los AVL la complejidad es constante porque, por el invariante de factores de balance, la cantidad de posiciones que tenemos que recorrer "hacia arriba" para encontrar un nodo derecho es como máximo 2. Por ende, la cantidad de ciclos a realizar tiene máximo constante y no depende del tamaño del arbol.

\end{Algoritmos}