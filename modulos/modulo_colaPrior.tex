\section{Modulo ColaPrioridad($\alpha$)}

Esta cola de prioridad genérica se representa sobre un conjunto de $\alpha$, el cual a su vez se implementa sobre un arbol de búsqueda autobalanceado (AVL). Gracias a esto, no solo podemos realizar cualquier función en tiempo logarítmico o menor, sino que también nos permite agregar la función Borrar, que nos permite eliminar cualquier elemento de la cola. A su vez, requerimos de un iterador al conjunto, que nos habilite a obtener el primer elemento de la cola en O(1). Para establecer correctamente la prioridad, se requiere que $\alpha$ tenga definido una relación de orden estricta.

Se usa $\#C$ para hablar de la cantidad de elementos de la cola

\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Cola de prioridad($\alpha$)}, \tadNombre{Iterador Unidireccional($\alpha$)}.

	\textbf{géneros}: \TipoVariable{colaPrior($\alpha$), itColaPrior($\alpha$)}.

	\TituloDis{Operaciones básicas de ColaPrioridad($\alpha$)}

	\InterfazFuncion{Vacía}{}{colaPrior}
	{$res$ $\igobs$ vacía}
	[$O(1)$]
	[crea una cola de prioridad vacía.]

	\InterfazFuncion{Encolar}{\Inout{c}{colaPrior}, \In{a}{$\alpha$}}{}
	[$c \igobs c_0$]
	{$res \igobs$ encolar($a, c_0$)}
	[$O(log(\#C) + copy(a))$]
	[encola un elemento.]
	[se almacena una copia de $a$.]

	\InterfazFuncion{Vacía?}{\In{c}{colaPrior}}{bool}
	{$res \igobs$ vacía?($c$)}
	[$O(1)$]
	[devuelve \texttt{true} si y solo si la cola no contiene elementos.]

	\InterfazFuncion{Próximo}{\In{c}{colaPrior}}{$\alpha$}
	[$\neg$ vacía(c)]
	{res $\igobs$ próximo?($c$)}
	[$O(1)$]
	[devuelve el elemento mas chico de la cola.]
	[$res$ no es modificable.]

	\InterfazFuncion{Desencolar}{\Inout{c}{colaPrior}}{}
	[$\neg$ vacía(c) $\land$ $c \igobs c_0$]
	{$res \igobs$ desencolar($c_0$)}
	[$O(log(\#C))$]
	[desencola el elemento mas chico de la cola.]

	\InterfazFuncion{Borrar}{\Inout{c}{colaPrior}, \In{a}{$\alpha$}}{colaPrior}
	[$c \igobs c_0$]
	{$res \igobs$ borrar($c_0$, a)}
	[$O(log(\#C))$]
	[desencola un elemento particular de la cola si el mismo pertenecía.]

  \TituloDis{Especificación de las operaciones auxiliares utilizadas en la interfaz}

  \begin{tad}{Cola de prioridad($\alpha$) Extendido}
    \parskip=0pt
    \tadExtiende{\tadNombre{Cola de prioridad($\alpha$)}}
    
    \tadTitulo{otras operaciones (exportadas)}
    \tadOperacion{borrar}{colaPrior($\alpha$), $\alpha$}{nat}{}
    \tadAxiomas
    \tadAxioma{borrar(c,a)}{\IF vacia?(c) $\oluego$ THEN 
    	c
    ELSE 
    	{\IF proximo(c) = a THEN
    		desencolar(c)
    	ELSE
    		encolar(proximo(c), borrar(desencolar(c),a))
    	FI}
    FI}
  \end{tad}
\end{Interfaz}

\begin{Representacion}
	\TituloDis{Representación de colaPrior}

	\begin{Estructura}{colaPrior($\alpha$)}[eCola]
		\begin{Tupla}[eCola]
			\tupItem{conjElem}{conjOrd($\alpha$)}
			\tupItem{menor}{$\alpha$}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación de ColaPrior($\alpha$)}
	
	\begin{enumerate}

		\item Y si hay elementos, hay un menor 

		\item El menor es efectivamente el menor del conjunto de elementos

	\end{enumerate}

	\Rep[eCola][e]{vacio?(e.conjElem) $\oluego$ e.menor $\igobs$ minimo(e.conjElem)}

	~

	\TituloDis{Función de Abstracción}

	\Abs[eCola]{colaPrior}[e]{d}{conjACola(e.conjElem)}
	
	~

	\tadOperacion{conjACola}{conj($\alpha$)}{colaPrior($\alpha$)}{}

	\tadAxioma{conjACola(conj)}{\IF $\emptyset$?(conj) THEN vacia ELSE encolar(minimo(conj),borrar(conj, minimo(conj))) FI}

	~

	\TituloDis{Representación del iterador}

	\begin{Estructura}{itColaPrior($\alpha$)}[itConjOrd($\alpha$)]
	\end{Estructura}

	\TituloDis{Invariante de Representación del iterador}

	\begin{enumerate}

		\item TODO creo que es true, pero confirmarmelo pls

	\end{enumerate}

	\Rep[eItCola][it]{true}

	\TituloDis{Función de Abstracción del iterador}

	\Abs[eItCola]{itUni($\alpha$)}[e]{d}
	{TODO}

\end{Representacion}

\begin{Algoritmos}
	\TituloDis{Algoritmos de ColaPrioridad($\alpha$)}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacia}{}{eCola}}
		res.conjElem $\leftarrow$ Vacio()\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializa el conjunto vacío

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iEncolar}{\Inout{c}{eCola}, \In{e}{$\alpha$}}{}}
		$\alpha$ : min $\leftarrow$ Actual(c.menor)\OdeLinea{1}
		c.conjElem $\leftarrow$ Agregar(c.conjElem, e)\OdeLinea{log($\#C$)}
		\If{e $<$ min}{
				itColaPrior: it $\leftarrow$ BuscarMinimo(CrearIt(c.conjElem))\OdeLinea{log($\#C$)} %TODO seba buscarMinimo es tuya
				c.menor $\leftarrow$ it
			}
	\end{algorithm}

	\complejidad: $O(log(\#C))$

	\justifcomp: hay que agregar el elemento al conjunto, y por invariante de AVL esto nos cuenta O(log($\#C$)). En caso de que sea el menor, hay que encontrar el elemento y cambiar el iterador en O(log($\#C$))

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacia?}{\In{c}{eCola}}{bool}}
		res $\leftarrow$ Vacio?(c.conjElem)\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: por la manera en la que se representa, si el conjunto de elementos esta vacío, la cola también

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iProximo}{\In{c}{eCola}}{$\alpha$}}
		res $\leftarrow$ c.menor\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: conseguimos el minimo del conjunto en O(1) gracias al iterador que tenemos guardado

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDesencolar}{\Inout{c}{eCola}}{}}
		res.raiz $\leftarrow$ NULL\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializan los punteros como nulos.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iBorrar}{\Inout{c}{eCola}, \In{e}{$\alpha$}}{}}
		$\alpha$ : min $\leftarrow$ Actual(c.menor)\OdeLinea{1}
		c.conjElem $\leftarrow$ Borrar(e, c.conjElem)\OdeLinea{log($\#C$)}
		\If{e = min}{
				itColaPrior: it $\leftarrow$ BuscarMinimo(CrearIt(c.conjElem))\OdeLinea{log($\#C$)}
				c.menor $\leftarrow$ it
			}
	\end{algorithm}

	\complejidad: $O(log(\#C))$

	\justifcomp: borrar el elemento del conjunto cuesta log($\#C$) y, si es el minimo, encontrar el nuevo minimo cuesta también log($\#C$)

	~

	\TituloDis{Algoritmos auxiliares}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{BuscarMinimo}{\In{a}{$\alpha$}, \In{nodo}{puntero(Nodo)}}{puntero(Nodo)}}
		\Pre{\texttt{SEBA}}
		\Post{SEBA}
		\BlankLine
		\If{SEBA}{
			SEBA $\leftarrow$ NAXIO\OdeLinea{CARLOS}
		}
	\end{algorithm}


%TODO no estan definidas las funciones del iterador, no se si alcanza con decirle que se comporta como un itConj
\end{Algoritmos}