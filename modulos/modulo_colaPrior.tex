\section{Modulo ColaPrioridad($\alpha$)}

Se usa $\#C$ para hablar de la cantidad de elementos de la cola

\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Cola de prioridad($\alpha$)}, \tadNombre{Iterador Unidireccional($\alpha$)}.

	\textbf{géneros}: \TipoVariable{colaPrior, itColaPrior}.

	\TituloDis{Operaciones básicas de ColaPrioridad($\alpha$)}

	\InterfazFuncion{Vacía}{}{colaPrior}
	{$res$ $\igobs$ vacía}
	[$O(1)$]
	[creación de una cola de prioridad vacía.]

	\InterfazFuncion{Encolar}{\Inout{c}{colaPrior}, \In{e}{$\alpha$}}{}
	[$c \igobs c_0$]
	{$res \igobs$ encolar($e, c_0$)}
	[$O(log(\#C) + copy(e))$]
	[encola una copia de e en la posición que le corresponde (log($\#C$)) y reacomoda el resto del arbol (log($\#C$))]

	\InterfazFuncion{Vacía?}{\In{c}{colaPrior}}{bool}
	{$res \igobs$ vacía?($c$)}
	[$O(1)$]
	[devuelve true si, y solo si, la cola no contiene elementos.]

	\InterfazFuncion{Próximo}{\In{c}{colaPrior}}{$\alpha$}
	[$\not$ vacía(c)]
	{res $\igobs$ próximo?($c$)}
	[$O(1)$]
	[devuelve el elemento mas chico de la cola]

	\InterfazFuncion{Desencolar}{\Inout{c}{colaPrior}}{}
	[$\not$ vacía(c) $\land$ $c \igobs c_0$]
	{$res \igobs$ desencolar($c_0$)}
	[$O(log(\#C))$]
	[elimina el elemento mas chico de la cola en O(1), pero buscar el nuevo más chico es O(log($\#C$))]

	\InterfazFuncion{Borrar}{\Inout{c}{colaPrior}, \In{e}{$\alpha$}}{colaPrior}
	[$c \igobs c_0$]
	{$res \igobs$ borrar($c_0$, e)}
	[$O(log(\#C))$]
	[elimina el elemento e de la cola en log($\#C$) y reacomoda el arbol (log($\#C$))]

  \TituloDis{Especificación de las operaciones auxiliares utilizadas en la interfaz}

  \begin{tad}{Diccionario(Jugador, Nat) Extendido}
    \parskip=0pt
    \tadExtiende{\tadNombre{Diccionario(Jugador, Nat)}}
    
    \tadTitulo{otras operaciones (exportadas)}
    \tadOperacion{borrar}{colaPrior($\alpha$), $\alpha$}{nat}{}
    \tadAxiomas
    \tadAxioma{borrar(c,a)}{\IF vacia?(c) $\oluego$ THEN 
    	c
    ELSE 
    	{\IF proximo(c) = a THEN
    		desencolar(c)
    	ELSE
    		encolar(proximo(c), borrar(desencolar(c),a))
    	FI}
    FI}
  \end{tad}
\end{Interfaz}

\begin{Representacion}
	\TituloDis{Representación de colaPrior}

	\begin{Estructura}{colaPrior}[eCola]
		\begin{Tupla}[eCola]
			\tupItem{conjElem}{conjOrd($\alpha$)}
			\tupItem{menor}{itConjOrd($\alpha$)}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación de ColaPrior($\alpha$)}
	
	\begin{enumerate}

		\item Si no hay elementos en el conjunto entonces no hay Actual en el iterador del menor

		\item Y si hay elementos hay un menor 

		\item El menor es efectivamente el menor de conjElem

	\end{enumerate}

	\Rep[eCola][e]{
	vacio?(e.conjElem) $\neq$ HayMas?(e.menor) $\yluego$ \\
	menor(CrearIt(e.conjElem), e.menor)}

	\TituloDis{Operaciones auxiliares}

	\tadOperacion{menor}{itConjOrd($\alpha$), itConjOrd($\alpha$)}{bool}{}

 	~

	\tadAxioma{menor(itConj, itMenor)}{
		HayMas?(itConj) $\impluego$ ((Actual(itConj) $>$ Actual(itMenor) $\lor$ Actual(itConj) = Actual(itMenor)) $\land$ menor(Avanzar(itConj), itMenor))
	}

	~

	\TituloDis{Función de Abstracción}

	\Abs[eCola]{colaPrior}[e]{d}
	{\IF vacio?(e.conjElem) THEN
		vacia
	ELSE
		encolar(Actual(e.menor), Abs(borrar(Actual(e.menor), e.conjElem)))
	}

	%%TODO

	\TituloDis{Representación del iterador}

	\begin{Estructura}{itConjOrd}[itJugs]
		\begin{Tupla}[itJugs]
			\tupItem{conjunto}{puntero(conjOrd)}
			\tupItem{pila}{pila(puntero(Nodo))}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación del iterador}

	\begin{enumerate}

		\item no hay nada hecho del iterador

	\end{enumerate}

	\Rep[itJugs][it]{hay iterador?}

	\TituloDis{Función de Abstracción del iterador}

	\Abs[eConj]{conjOrd}[e]{d}
	{($\forall a$: $\alpha$) a $\in$ d = definido?(a, e.raiz)}

\end{Representacion}

\begin{Algoritmos}
	\TituloDis{Algoritmos de ColaPrioridad($\alpha$)}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacia}{}{eCola}}
		res.conjElem $\leftarrow$ Vacio()\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializa el conjunto vacío

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iEncolar}{\Inout{c}{eCola}, \In{e}{$\alpha$}}{}}
		c.conjElem $\leftarrow$ Agregar(c.conjElem, e)\OdeLinea{O(log($\#C$))}
		\If{e $<$ c.menor}{
				%TODO cambiar el iterador menor al nuevo elemento
			}
	\end{algorithm}

	\complejidad: $O(log(\#C))$

	\justifcomp: hay que agregar el elemento al conjunto, y por invariante de AVL esto nos cuenta O(log($\#C$)). En caso de que sea el menor, hay que encontrar el elemento y cambiar el iterador en O(log($\#C$))

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iVacia?}{\In{c}{eCola}}{bool}}
		res $\leftarrow$ Vacio?(c.conjElem)\OdeLinea{O(1)} %TODO al conjOrd le estaría faltando esta funcion
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: por la manera en la que se representa, si el conjunto de elementos esta vacío, la cola también

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDesencolar}{\Inout{c}{eCola}}{}}
		res.raiz $\leftarrow$ NULL\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializan los punteros como nulos.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iBorrar}{\Inout{c}{eCola}, \In{e}{$\alpha$}}{}}
		res.raiz $\leftarrow$ NULL\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializan los punteros como nulos.

\end{Algoritmos}