\section{Módulo Juego}

La cantidad de cada pokémon se guarda en un diccionario basado en trie, usando los nombres como claves. Sus posiciones se guardan en un Conjunto Lineal con inserción rápida, y en el mismo mapa se guarda el pokémon que se ubica en dicha posición (este valor se invalida si la posición no está en el conjunto, como cuando se captura el pokémon). 

\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Juego}.

	\textbf{géneros}: \TipoVariable{juego}, \TipoVariable{itJugadores}.

	\textbf{servicios usados}: \tadNombre{Vector($\alpha$)}, \tadNombre{DiccionarioString($\alpha$)}, \tadNombre{Conjunto Lineal($\alpha$)}


	\InterfazFuncion{CrearJuego}{\In{m}{mapa}}{juego}
	{$res \igobs$ crearJuego(m)}
	[$O()$]
	[crea un juego vacío usando el mapa provisto.]
	[se guarda una copia de $m$.]

	\InterfazFuncion{AgregarPokémon}{\Inout{j}{juego}, \In{pk}{pokemon}, \In{c}{coor}}{}
	[$j \igobs j_0 \land$ puedoAgregarPokémon($c,j_0$)]
	{$j \igobs$ agregarPokémon($pk, c, j_0$)}
	[$O(|pk_{max}|)$]
	[agrega un pokemon al juego.]

	\InterfazFuncion{AgregarJugador}{\Inout{j}{juego}}{nat}
	[$j \igobs j_0$]
	{$j \igobs$ agregarJugador($j$)}
	[$O()$]
	[registra un nuevo jugador y devuelve su ID.]

	\InterfazFuncion{Conectarse}{\Inout{j}{juego}, \In{e}{jugador}, \In{c}{coor}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego \neg$conectado($e,j_0$) $\land$ posExistente(mapa($j_0$))]
	{$j \igobs$ conectarse($e, c, j_0$)}
	[$O(log(\#Jugadores(j)))$]
	[conecta al jugador al juego.]

	\InterfazFuncion{Desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego$ conectado($e,j_0$)]
	{$j \igobs$ desconectarse($e, j_0$)}
	[$O()$]
	[desconecta al jugador del juego.]

	\InterfazFuncion{Moverse}{\Inout{j}{juego}, \In{e}{jugador}, \In{c}{coor}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego$ conectado($e,j_0$) $\land$ posExistente(mapa($j_0$))]
	{$j \igobs$ moverse($e, c, j_0$)}
	[$O()$]
	[mueve el jugador a la posición elegida. Si el movimiento es ilegal, sanciona al jugador o lo expulsa si excede el límite de sanciones. Aumenta los contadores de captura para otros jugadores donde corresponde y puede provocar la captura de pokémons.]

	\InterfazFuncion{Mapa}{\In{j}{juego}}{mapa}
	{alias($res$ = mapa($j$))}
	[$O(1)$]
	[devuelve el mapa del juego.]
	[$res$ no es modificable.]

	\InterfazFuncion{Jugadores}{\In{j}{juego}}{itBi(jugador)}
	{$res \igobs$ crearItBi($\secuvacia$, jugadores($j$)) $\land$ alias(esPermutacion(SecuSuby($res$), jugadores($j$))) $\land$ vacia?(Anteriores($res$))}
	[$O(1)$]
	[devuelve un iterador del conjunto de jugadores registrados (no expulsados).]
	[el iterador se invalida si se expulsa al siguiente jugador del iterador, o si se agrega un nuevo jugador y el iterador había llegado al final. Además, anteriores($res$) y siguientes($res$) podrían cambiar completamente ante cualquier operación que modifique la lista de jugadores.]

	\InterfazFuncion{EstaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ estaConectado($e, j$)}
	[$O()$]
	[devuelve si el jugador está conectado al juego.]

	\InterfazFuncion{Sanciones}{\In{j}{juego}, \In{e}{jugador}}{nat}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ sanciones($e, j$)}
	[$O()$]
	[devuelve la cantidad de sanciones que el jugador posee.]

	\InterfazFuncion{Posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ posicion($e, j$)}
	[$O()$]
	[devuelve la posición actual del jugador.]

	\InterfazFuncion{Pokémons}{\In{j}{juego} \In{e}{jugador}}{itBi(tupla(pokemon, nat))}
	% TODO fucking tuplas
	% TODO fucking metapredicado alias e iteradores
	{$res \igobs$ crearItBi($\secuvacia$, pokemons($j$)) $\land$ alias(esPermutacion(SecuSuby($res$), pokemons($j$)))}
	[$O()$]
	[devuelve un iterador al conjunto de los pokémons capturados por un jugador, y la cantidad de los mismos.]
	[el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador.]

	\InterfazFuncion{Expulsados}{\In{j}{juego}}{itBi(jugador)}
	{$res \igobs$ crearItBi($\secuvacia$, expulsados($j$)) $\land$ alias(esPermutacion(SecuSuby($res$), expulsados($j$))) $\land$ vacia?(Anteriores($res$))}
	[$O()$]
	[devuelve un iterador del conjunto de jugadores expulsados.]
	[el iterador se invalida si se expulsa al siguiente jugador del iterador, o si se agrega un nuevo jugador y el iterador había llegado al final. Además, anteriores($res$) y siguientes($res$) podrían cambiar completamente ante cualquier operación que modifique la lista de jugadores.]

	\InterfazFuncion{PosConPokémons}{\In{j}{juego}}{conj(coor)}
	{alias($res$ = posConPokémons(j))}
	[$O(1)$]
	[devuelve el conjunto de posiciones que contienen un pokémon.]
	[$res$ no es modificable.]

	\InterfazFuncion{PokémonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}
	[$c \ \land$ posConPokemon($j$)]
	{$res \igobs$ pokémonEnPos($c,j$)}
	[$O()$]
	[devuelve el pokémon que se encuentra en la posición.]

	\InterfazFuncion{PuedoAgregarPokémon}{\In{j}{juego}, \In{c}{coor}}{bool}
	{$res \igobs$ puedoAgregarPokémon($c,j$)}
	[$O()$]
	[devuelve si un nuevo pokémon puede ser agregado a esa posición (no debe haber ningún pokémon cerca).]

	\InterfazFuncion{HayPokémonCercano}{\In{j}{juego}, \In{c}{coor}}{bool}
	{$res \igobs$ hayPokémonCercano($c,j$)}
	[$O()$]
	[devuelve si hay algún pokémon cerca de la posición.]

	\InterfazFuncion{PosPokémonCercano}{\In{j}{juego}, \In{c}{coor}}{coor}
	[hayPokémonCercano($c,j$)]
	{$res \igobs$ posPokémonCercano($c,j$)}
	[$O()$]
	[devuelve el pokémon que se encuentra cerca de la posición.]

	% TODO hace falta exponer esto?
	% cambió la aridad, anotar en consideraciones
	\InterfazFuncion{EntrenadoresPosibles}{\In{j}{juego}, \In{c}{coor}}{conj(jugador)}
	[hayPokémonCercano($c,j$)]
	{$res \igobs$ entrenadoresPosibles($c,j$)}
	[$O()$]
	[devuelve el conjunto de jugadores esperando a capturar el pokémon que se encuentra en la posición.]
	[$res$ no es modificable.]

	\InterfazFuncion{IndiceRareza}{\In{j}{juego}, \In{pk}{pokemon}}{nat}
	[$pk \in$ pokemons($j$)]
	{$res \igobs$ indiceRareza($pk,j$)}
	[$O(|pk_{max}|)$]
	[calcula el índice de rareza de un pokémon.]

	\InterfazFuncion{CantPokémonsTotales}{\In{j}{juego}}{nat}
	{$res \igobs$ cantPokémonsTotales($j$)}
	[$O(1)$]
	[devuelve la cantidad de pokémons en juego.]

	\InterfazFuncion{CantMismaEspecie}{\In{j}{juego}, \In{pk}{pokemon}}{nat}
	[$pk \in$ pokemons($j$)]
	{$res \igobs$ cantMismaEspecie($j$)}
	[$O(|pk_{max}|)$]
	[devuelve la cantidad de pokémons de la especie especificada en juego.]

	\TituloDis{Operaciones del iterador de jugadores}

	El iterador que presentamos permite recorrer tanto los jugadores registrados válidos como los expulsados de forma unidireccional. El iterador es solo un contador (devuelve las IDs de los jugadores, no su detalle).


	\InterfazFuncion{CrearIt}{\In{j}{juego}, \In{elim?}{bool}}{itJugadores}
	{($\neg$elim? $\land$ esPermutacion(SecuSuby($res$), jugadores($j$))) $\land$ (elim? $\land$ esPermutacion(SecuSuby($res$), expulsados($j$))) $\land$ vacia?(Anteriores($res$))}
	[$O(1)$]
	[crea un iterador bidireccional de los jugadores validos o expulsados.]
	[el iterador se invalida si se expulsa al siguiente jugador del iterador, o si se agrega un nuevo jugador y el iterador había llegado al final. Además, siguientes($res$) podrían cambiar completamente ante cualquier operación que modifique la lista de jugadores.]

	\InterfazFuncion{HaySiguiente}{\In{it}{itJugadores}}{bool}
	{$res$ $\igobs$ haySiguiente?($it$)}
	[$O(1)$]
	[devuelve \texttt{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

	\InterfazFuncion{Siguiente}{\In{it}{itJugadores}}{jugador}
	[HaySiguiente?($it$)]
	{$res$ $\igobs$ Siguiente($it$)}
	[$O(|c_{max}|))$]
	[devuelve el elemento siguiente a la posición del iterador, como tupla clave-valor.]

	\InterfazFuncion{Avanzar}{\Inout{it}{itJugadores}}{}
	[$it = it_0$ $\land$ HaySiguiente?($it$)]
	{$it$ $\igobs$ Avanzar($it_0$)}
	[$O(1)$]
	[avanza a la posición siguiente del iterador.]

\end{Interfaz}

\begin{Representacion}

	\TituloDis{Representación de Juego}

	\begin{Estructura}{Juego}[pokego]
		\begin{Tupla}[pokego]
			\tupItem{mapa}{mapa}
			\tupItem{pokemons}{diccString(nat)}
			\tupItem{posConPokemons}{conj(coor)}
			\tupItem{\\jugadores}{vector(puntero(infoJugador))}
			\tupItem{\\grillaPos}{arreglo\_dimensionable de (arreglo\_dimensionable de infoPos)}
			\tupItem{\\cantPokemons}{nat}
		\end{Tupla}

		\begin{Tupla}[infoJugador]
			\tupItem{sanciones}{nat}
			\tupItem{conectado?}{bool}
			\tupItem{posicion}{coor}
			\tupItem{cantPokemons}{nat}
			\tupItem{\\pokemonsCapturados}{diccString(nat)}
		\end{Tupla}

		\begin{Tupla}[infoPos]
			\tupItem{pokemon}{pokemon}
			\tupItem{contadorCaptura}{nat}
			\tupItem{jugEsperandoCaptura}{dicPrior}
		\end{Tupla}

	\end{Estructura}
	
	\TituloDis{Invariante de Representación del Juego}

	\begin{enumerate}
		
		\item Todas las coordenadas pertenecientes a posConPokemons pertenecen a las coordenadas válidas del mapa

		\item La suma de todos los significados del diccionario pokemons es igual a cantPokemons
		
		\item No hay dos coordenadas pertenecientes a posConPokemons a menos de 5 de distancia
		
		\item Para cada miembro de jugadores, las claves de pokemonsCapturados pertenecen a las claves de pokemons

		\item Para cada clave de pokemons, su significado es la suma de:
		\begin{itemize}
			\item todos los significados de esa misma clave en los pokemonsCapturados de cada miembro de jugadores donde la clave existe y el jugador no fue eliminado
			\item la cantidad de coordenadas de posConPokemons donde se encuentra un pokemon igual a esa clave
		\end{itemize}
		%TODO definir como se saca que poke hay en cada posicion
		
		\item Para cada miembro de jugadores, si el jugador esta conectado su posición tiene que pertenecer a las coordenadas válidas del mapa
		
	\end{enumerate}


	\Rep[pokego][e]{
	($\forall c$: coor)(c $\in$ e.posConPokemons $\implies$ c $\in$ coordenadas(e.mapa)) $\land$ e.cantPokemons == sumaSignificadosPoke(claves(e.pokemons), e.pokemons) $\land$ ($\forall c,d$: coor)(c $\in$ e.posConPokemons $\land$ d $\in$ e.posConPokemons $\implies$ c = d $\lor$ distEuclidea(c,d) $>$ 25) $\land$ ($\forall i$:nat)(i $<$ long(e.jugadores) $\implies$ claves(e.jugadores[i]$\rightarrow$pokemonsCapturados) $\subseteq$ claves(e.pokemons)) $\land$  ($\forall i$:nat)(i $<$ long(e.jugadores) $\yluego$ e.jugadores[i]$\rightarrow$sanciones $<$ 5 $\implies$ e.jugadores[i]$\rightarrow$conectado $\implies$ e.jugadores[i]$\rightarrow$posicion $\in$ coordenadas(e.mapa))
	}
	
	~
	
	\tadOperacion{sumaSignificadosPoke}{conj(pokemon)/cs, dicc(String{,}Nat)/dic}{nat}{cs $\subseteq$ claves(dic)}
		
	~

	\tadAxioma{sumaSignificadosPoke(cs, dic)}
	{\IF vacia?(cs) THEN
		0
	ELSE
		obtener(dic, dameUno(cs)) + sumaSignificadosPoke(sinUno(cs), dic)
	FI}
		
	~
	
	\TituloDis{Función de Abstracción}

	\Abs[pokego]{juego}[e]{j}{
		mapa(j) == e.mapa $\land$ ($\forall p:$ jugador)(p $\in$ jugadores(j) $=$ long(e.jugadores) $>$ p $\yluego$ sanciones(p, j) == e.jugadores[p]$\rightarrow$sanciones $\land$ (sanciones(p, j) $<$ 5 $\impluego$ estaConectado(p, j) == e.jugadores[p]$\rightarrow$conectado?) $\land$ (estaConectado(p, j) $\impluego$ posicion(p, j) == e.jugadores[p]$\rightarrow$posicion)) $\land$ pokemons(j) == listaPoke(claves(e.pokemons), e.pokemons) $\land$ expulsados(j) == listaExpulsados(e, long(e.jugadores)) $\land$ ($\forall c:$ coor) (c $\in$ posConPokemons(j) == c $\in$ e.posConPokemons) $\land$ TODO POKEMON EN POS, TODO MOV PARA CAPTURA
	}
	
	~

	\tadOperacion{listaPoke}{conj(pokemon)/cs, dicc(String{,}Nat)/dic}{multiconj(pokemon)}{cs $\subseteq$ claves(dic)}
	\tadOperacion{agregarPoke}{pokemon, nat}{multiconj(pokemon)}{}
	\tadOperacion{listaExpulsados}{pokego, nat}{conj(jugador)}{}
		 
	~

	\tadAxioma{listasPoke(cs, dic)}
	{\IF vacia?(cs) THEN
		$\emptyset$
	ELSE
		agregarPoke(dameUno(cs),obtener(dameUno(cs),dic)) $\bigcup$ listasPoke(sinUno(cs), dic)
	FI}
		
	~

	\tadAxioma{agregarPoke(p, n)}
	{\IF n == 0 THEN
		$\emptyset$
	ELSE
		Ag(p, agregarPoke(p, n-1))
	FI}
	
	\tadAxioma{listaExpulsados(p, n)}
	{\IF n = 0 THEN
		$\emptyset$
	ELSE
		{\IF p.jugadores[n-1]$\rightarrow$sanciones = 5 THEN
			Ag(*p.jugadores[n-1],listaExpulsados(p,n-1))
		ELSE
			listaExpulsados(p,n-1)
		FI}
	FI}
	
	
	%TODO iterador de jugadores :)


	\TituloDis{Representación del iterador de jugadores}

	\begin{Estructura}{itJugadores}[itJug]
		\begin{Tupla}[itJug]
			\tupItem{puntero(vector(puntero(infoJugador)))}{listaJugadores}
			\tupItem{nat}{contador}
			\tupItem{bool}{eliminados?}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación del iterador}

	\begin{enumerate}

		\item La lista de jugadores no es nula

	\end{enumerate}

	\Rep[itJug][it]{it.listaJugadores $\neq$ NULL}


	\TituloDis{Función de Abstracción del iterador}

	\Abs[itJug]{itBi(nat)}[it]{b}{Anteriores(b) $=$ seleccionar(primeros(*it.listaJugadores, it.contador), it.eliminados?) \\ $\land$ Siguientes(b) $=$ seleccionar(ultimos(*it.listaJugadores, it.contador), it.eliminados?)}

	~

	\tadOperacion{selecionar}{secu(infoJugador)/js,  bool/elim?}{secu(nat)}{}

	\tadOperacion{primeros}{secu(infoJugador)/js,  nat/n}{secu(infoJugador)}{}

	\tadOperacion{ultimos}{secu(infoJugador)/js,  nat/n}{secu(infoJugador)}{}

	~

	\tadAxioma{selecionar(js, elim?)}
	{\IF vacia?(js) THEN
		\secuvacia
	ELSE
		{\IF (ult(js).sanciones $<$ 5) = elim? THEN  seleccionar(com(js), elim?) \circulito (long(js) - 1)) ELSE seleccionar(com(js), elim?) FI}
	FI}

	\tadAxioma{primeros(js, n)}
	{\IF 0?(n) $\lor$ vacia?(js) THEN
		\secuvacia
	ELSE
		prim(js) \puntito primeros(fin(js), n-1)
	FI}


	\tadAxioma{ultimos(js, n)}
	{\IF 0?(n) $\lor$ vacia?(js) THEN
		\secuvacia
	ELSE
		ultimos(com(js), n-1) \circulito ult(js)
	FI}

\end{Representacion}


\begin{Algoritmos}

	\TituloDis{Algorítmos de Juego}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iCrearJuego}{\In{m}{mapa}}{pokego}}
		res.mapa $\leftarrow$ m\;
		res.pokemons $\leftarrow$ CrearDiccionario()\;
		res.posConPokemons $\leftarrow$ Vacio()\;
		res.jugadores $\leftarrow$ Vacio()\;
		res.cantPokemons $\leftarrow$ 0\;
		res.grillaPos $\leftarrow$ CrearArreglo(Alto(m))\;
		\For{$i \leftarrow 0$ \KwTo Alto($m$)}{
			res.grillaPos[i] $\leftarrow$ CrearArreglo(Ancho(m))\;
		}
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iAgregarPokémon}{\Inout{j}{pokego}, \In{pk}{pokemon}, \In{c}{coor}}{}}
		j.cantPokemons $\leftarrow$ j.cantPokemons + 1\;
		\eIf{Definido(j.pokemons, pk)}{
			nat: nuevaCant $\leftarrow$ Obtener(j.pokemons, pk) + 1\;
			Definir(j.pokemons, pk, nuevaCant)\;
		}{
			Definir(j.pokemons, pk, 1)\;
		}

		j.grilla[Latitud(c)][Longitud(c)].pokemon $\leftarrow$ pk\;

		nat : i $\leftarrow$ 0\;
		\While{i $<$ 5}{
			nat : j $\leftarrow$ 0\;
			\While{DistEuclidea(c, CrearCoor(Latitud(c) + i, Longitud(c) + j)) $\leq$ 4}{
				\If{PosExistente(j.mapa, CrearCoor(Latitud(c) + i, Longitud(c) + j))}{
					j.grilla[i][j].contadorCaptura $\leftarrow$ 0\;
				}
				j $\leftarrow$ j + 1\;
			}
			i $\leftarrow$ i + 1\;
		}
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iAgregarJugador}{\Inout{j}{pokego}}{nat}}
		res $\leftarrow$ Longitud(j.jugadores)\; 
		AgregarAtras(j.jugadores, CrearInfoJugador())\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearInfoJugador}{}{infoJugador}}
		res.sanciones $\leftarrow$ 0\;
		res.conectado? $\leftarrow$ false\;
		% res.posicion $\leftarrow$ CREO QUE NADA, PREGUNTAR SI SE PUEDE DEJAR SIN INIT
		res.cantPokemons $\leftarrow$ 0\;
		res.pokemonsCapturados $\leftarrow$ CrearDiccionario()\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iConectarse}{\Inout{j}{pokego}, \In{e}{jugador}, \In{c}{coor}}{}}
		(*j.jugadores[e]).conectado? $\leftarrow$ true\;
		(*j.jugadores[e]).posicion $\leftarrow$ c\;
		AgregarAColas(j, e)\;
		%% RESETEAR LOS CONTADORES
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDesconectarse}{\Inout{j}{pokego}, \In{e}{jugador}}{}}
		(*j.jugadores[e]).conectado? $\leftarrow$ false\;
		RemoverDeColas(j, e)\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverDeColas}{\Inout{j}{pokego}, \In{e}{jugador}}{}}
		coor: c $\leftarrow$ (*j.jugadores[e]).posicion\;
		nat : i $\leftarrow$ 0\;
		\While{i $<$ 3}{
			nat : j $\leftarrow$ 0\;
			\While{j $<$ 3}{
				\If{DistEuclidea(c, CrearCoor(Latitud(c) + i, Longitud(c) + j)) $\leq$ 4}{
					\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) + i, Longitud(c) + j)}{
						Borrar(j.grillaPos[Latitud(c) + i][Longitud(c) + j].jugEsperandoCaptura, e)\;
					}
				} 
				\If {DistEuclidea(c, CrearCoor(Latitud(c) + i, Longitud(c) - j)) $\leq$ 4}{
					\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) + i, Longitud(c) - j)}{
						Borrar(j.grillaPos[Latitud(c) + i][Longitud(c) - j].jugEsperandoCaptura, e)\;
					}
				} 
				\If {DistEuclidea(c, CrearCoor(Latitud(c) - i, Longitud(c) + j)) $\leq$ 4}{
					\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) - i, Longitud(c) + j)}{
						Borrar(j.grillaPos[Latitud(c) - i][Longitud(c) + j].jugEsperandoCaptura, e)\;
					}
				} 
				\If {DistEuclidea(c, CrearCoor(Latitud(c) - i, Longitud(c) - j)) $\leq$ 4}{
						\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) - i, Longitud(c) - j)}{
							Borrar(j.grillaPos[Latitud(c) - i][Longitud(c) - j].jugEsperandoCaptura, e)\;
					}
				}
			j $\leftarrow$ j+1\;	
			}							
		i $\leftarrow$ i+1\;
		}				
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{AgregarAColas}{\Inout{j}{pokego}, \In{e}{jugador}}{}}
			coor: c $\leftarrow$ (*j.jugadores[e]).posicion\;
			nat : i $\leftarrow$ 0\;
			\While{i $<$ 3}{
				nat : j $\leftarrow$ 0\;
				\While{j $<$ 3}{
				\If{DistEuclidea(c, CrearCoor(Latitud(c) + i, Longitud(c) + j)) $\leq$ 4}{
					\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) + i, Longitud(c) + j)}{
						Definir(j.grillaPos[Latitud(c) + i][Longitud(c) + j].jugEsperandoCaptura, e, (*j.jugadores[e]).cantPokemons)\;
					}
				} 
				\If {DistEuclidea(c, CrearCoor(Latitud(c) + i, Longitud(c) - j)) $\leq$ 4}{
					\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) + i, Longitud(c) - j)}{
						Definir(j.grillaPos[Latitud(c) + i][Longitud(c) - j].jugEsperandoCaptura, e, (*j.jugadores[e]).cantPokemons)\;
					}
				} 
				\If {DistEuclidea(c, CrearCoor(Latitud(c) - i, Longitud(c) + j)) $\leq$ 4}{
					\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) - i, Longitud(c) + j)}{
						Definir(j.grillaPos[Latitud(c) - i][Longitud(c) + j].jugEsperandoCaptura, e, (*j.jugadores[e]).cantPokemons)\;
					}
				} 
				\If {DistEuclidea(c, CrearCoor(Latitud(c) - i, Longitud(c) - j)) $\leq$ 4}{
						\If{Pertenece(j.posConPokemons, CrearCoor(Latitud(c) - i, Longitud(c) - j)}{
							Definir(j.grillaPos[Latitud(c) - i][Longitud(c) - j].jugEsperandoCaptura, e, (*j.jugadores[e]).cantPokemons)\;
					}
				}
			j $\leftarrow$ j+1\;	
			}							
		i $\leftarrow$ i+1\;
		}	
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iMoverse}{\Inout{j}{pokego}, \In{e}{jugador}, \In{c}{coor}}{}}
		RemoverDeColas(j, e)\;
		\If{\textbf{not} HayCamino(j.mapa, Posicion(j,e), c) \textbf{or} DistEuclidea(Posicion(j,e), c) $>$ 100}{
			(*j.jugadores[e]).sanciones $\leftarrow$ (*j.jugadores[e]).sanciones + 1\;
		}
		\eIf{(*j.jugadores[e]).sanciones = 5}{
			itDiccString(nat) : pokesABorrar $\leftarrow$ CrearIt((*j.jugadores[e]).pokemonsCapturados)\;
			\While{HaySiguiente(pokesABorrar)}{
				tupla(calve: String, significado: Nat) : sig $\leftarrow$ Siguiente(pokesABorrar)\;

				nat: nuevaCant $\leftarrow$ Obtener(j.pokemons, sig.clave) - sig.significado\;
				Definir(j.pokemons, pk, nuevaCant)\;
				j.cantPokemons $\leftarrow$ j.cantPokemons - sig.significado\;
			}
		}{
			(*j.jugadores[e]).posicion $\leftarrow$ c\;
			AgregarAColas(j, e, c)\;
		}

		%% COMP AUTO DE CAPTURA, ETC
		it $\leftarrow$ CrearItUni(j.posConPokemons)\;
		\While{HayMas?(it)}{ %%Itero la posiciones con pks
			coor: coorConPk $\leftarrow$ Actual(it)\; 
			\If{DistEuclidead(c, coorConPk) $>$ 4}{ %me fijo si es mas lejos que el rango de captura
				infoPos: posPk $\leftarrow$ j.grillaPos[Latitud(coorConPk)][Longitud(coorConPk)]\;
				posPk.contadorCaptura $\leftarrow$ posPk.contadorCaptura +1 \;
				\If{posPk.contadorCaptura = 10}{ 
					%%--Captura--
					pokemon: pk $\leftarrow$ posPk.pokemon\;
					jugador: captor $\leftarrow$ Menor(posPk.jugEsperandoCaptura)\; %Busca el menor
					(*j.jugadores[captor]).cantPokemons $\leftarrow$ (*j.jugadores[captor]).cantPokemons + 1\; %Aumenta la catidad de polkemons
					\eIf{Definido((*j.jugadores[captor]).pokemonsCapturados, pk)}{ %Define que pokemon captura en el dic
						nat: nuevaCant $\leftarrow$ Obtener((*j.jugadores[captor]).pokemonsCapturados, pk) + 1\;
						Definir((*j.jugadores[captor]).pokemonsCapturados, pk, nuevaCant)\;
					}{
						Definir((*j.jugadores[captor]).pokemonsCapturados, pk, 1)\;
					}
					AgregarAColas(captor, e)\; %Actualiza las prioridades de la proxima captura
				}
			}
		}
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iMapa}{\In{j}{pokego}}{mapa}}
		res $\leftarrow$ j.mapa\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iJugadores}{\In{j}{pokego}}{itBi(jugador)}}
		res $\leftarrow$ CrearIt(j, false)\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iEstaConectado}{\In{j}{pokego}, \In{e}{jugador}}{bool}}
		res $\leftarrow$ (*j.jugadores[e]).conectado?\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iSanciones}{\In{j}{pokego}, \In{e}{jugador}}{nat}}
		res $\leftarrow$ (*j.jugadores[e]).sanciones\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPosicion}{\In{j}{pokego}, \In{e}{jugador}}{coor}}
		res $\leftarrow$ CrearCoor(Latitud((*j.jugadores[e]).posicion), Longitud((*j.jugadores[e]).posicion))\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPokémons}{\In{j}{pokego}, \In{e}{jugador}}{itBi(tupla(pokemon, nat))}}
		res $\leftarrow$ CrearIterador((*j.jugadores[e]).pokemonsCapturados)\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iExpulsados}{\In{j}{pokego}}{itBi(jugador)}}
		res $\leftarrow$ CrearIt(j, true)\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPosConPokémons}{\In{j}{pokego}}{conj(coor)}}
		res $\leftarrow$ j.posConPokemons\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPokémonEnPos}{\In{j}{pokego}, \In{c}{coor}}{pokemon}}
		%% ESTUPIDA GRILLA
		res $\leftarrow$ j.grillaPos[Latitud(c)][Longitud(c)].pokemon\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPuedoAgregarPokémon}{\In{j}{pokego}, \In{c}{coor}}{bool}}
		res $\leftarrow$ PosExistente(j, c) \textbf{and} HayPokémonEnDistancia(j, c, 25)\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:


	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{HayPokémonEnDistancia}{\In{j}{pokego}, \In{c}{coor}, \In{n}{nat}}{bool}}
		res $\leftarrow$ false\;
		nat : i $\leftarrow$ 0\;
		\While{i $<$ 5}{
			nat : j $\leftarrow$ 0\;
			\While{DistEuclidea(c, CrearCoor(Latitud(c) + i, Longitud(c) + j)) $\leq$ n}{
				coor : d $\leftarrow$ CrearCoor(Latitud(c) + i, Longitud(c) + j)\;
				\If{Pertenece(j.posConPokemons, d)}{
					res $\leftarrow$ true\;
					%% ES LEGAL USAR RETURN?
					\textbf{return}\;
				}
				j $\leftarrow$ j + 1\;
			}
			i $\leftarrow$ i + 1\;
		}
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iHayPokémonCercano}{\In{j}{pokego}, \In{c}{coor}}{bool}}
		res $\leftarrow$ HayPokémonEnDistancia(j, c, 4)\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPosPokémonCercano}{\In{j}{pokego}, \In{c}{coor}}{coor}}
		nat : i $\leftarrow$ 0\;
		\While{i $<$ 5}{
			nat : j $\leftarrow$ 0\;
			\While{DistEuclidea(c, CrearCoor(Latitud(c) + i, Longitud(c) + j)) $\leq$ n}{
				coor : d $\leftarrow$ CrearCoor(Latitud(c) + i, Longitud(c) + j)\;
				\If{Pertenece(j.posConPokemons, d)}{
					res $\leftarrow$ d\;
					%% ES LEGAL USAR RETURN?
					\textbf{return}\;
				}
				j $\leftarrow$ j + 1\;
			}
			i $\leftarrow$ i + 1\;
		}
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iEntrenadoresPosibles}{\In{j}{pokego}, \In{c}{coor}}{conj(jugador)}}
		res $\leftarrow$ Claves(j.grillaPos[Latitud(c)][Longitud(c)].jugEsperandoCaptura)
		%% CREAR ALGO QUE OBTENGA EL CONJ DE LOS JUGADORES DE LA COLA DE PRIOR
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iIndiceRareza}{\In{j}{pokego}, \In{pk}{pokemon}}{nat}}
		nat : cantPk $\leftarrow$ Obtener(j.pokemones, pk)\;
		res $\leftarrow$ 100 - (cantPk $\times$ 100 $\div$ j.cantPokemons)\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iCantPokémonsTotales}{\In{j}{pokego}}{nat}}
		res $\leftarrow$ j.cantPokemons\;
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iCantMismaEspecie}{\In{j}{pokego}, \In{pk}{pokemon}}{nat}}
		res $\leftarrow$ Obtener(j.pokemones, pk)\; 
	\end{algorithm}

	\complejidad: $O()$

	\justifcomp:


	\TituloDis{Algorítmos del iterador}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearIt}{\In{j}{pokego}, \In{elim?}{bool}}{itJugadores}}
		res.listaJugadores $\leftarrow$ \&(j.jugadores)\OdeLinea{1}
		res.contador $\leftarrow$ 0\OdeLinea{1}
		res.eliminados $\leftarrow$ elim?\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializa el iterador.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{HaySiguiente}{\In{it}{itJugadores}}{bool}}
		nat: i $\leftarrow$ it.contador\OdeLinea{1}
		res $\leftarrow$ false\OdeLinea{1}
		\While(\OdeBloque{\#j}){i $<$ long(*it.listaJugadores)}{
			\If{((*it.listaJugadores)[i].sanciones $<5$) = it.eliminados?}{
				res $\leftarrow$ true\OdeLinea{1}
				\textbf{return}\;
			}
			i $\leftarrow$ i + 1\OdeLinea{1}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Siguiente}{\In{it}{itJugadores}}{jugador}}
		nat: i $\leftarrow$ it.contador\OdeLinea{1}
		\While(\OdeBloque{\#j}){i $<$ long(*it.listaJugadores)}{
			\If{((*it.listaJugadores)[i].sanciones $<5$) = it.eliminados?}{
				res $\leftarrow$ i\OdeLinea{1}
				\textbf{return}\;
			}
			i $\leftarrow$ i + 1\OdeLinea{1}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Avanzar}{\Inout{it}{itJugadores}}{}}
		nat: i $\leftarrow$ it.contador\OdeLinea{1}
		\While(\OdeBloque{\#j}){i $<$ long(*it.listaJugadores)}{
			\If{((*it.listaJugadores)[i].sanciones $<5$) = it.eliminados?}{
				it.contador $\leftarrow$ i + 1\OdeLinea{1}
				\textbf{return}\;
			}
			i $\leftarrow$ i + 1\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(\#j)$

	\justifcomp: como la lista de jugadores y la de eliminados son la misma, debe revisarla en su totalidad hasta encontrar otro elemento válido.

	~


\end{Algoritmos}
