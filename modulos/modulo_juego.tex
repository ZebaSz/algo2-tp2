\section{Módulo Juego}

La cantidad de cada pokémon se guarda en un diccionario basado en trie, usando los nombres como claves. Sus posiciones se guardan en un Conjunto Lineal con inserción rápida, y en el mismo mapa se guarda el pokémon que se ubica en dicha posición (este valor se invalida si la posición no está en el conjunto, como cuando se captura el pokémon).

Utilizaremos la misma notación para complejidades que en el enunciado:

\begin{itemize}
	\item $J$ es la cantidad total de jugadores que fueron agregados al juego.

	\item $|P|$ es el nombre más largo para un pokémon en el juego.

	\item $EC$ es la máxima cantidad de jugadores esperando para atrapar un pokémon.

	\item $PS$ es la cantidad de pokémon salvajes.

	\item $PC$ es la máxima cantidad de pokémon capturados por un jugador.
\end{itemize}

\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Juego}.

	\textbf{géneros}: \TipoVariable{juego}, \TipoVariable{itJugadores}.

	\textbf{servicios usados}: \tadNombre{Coordenada}, \tadNombre{Mapa}, \tadNombre{Vector($\alpha$)}, \tadNombre{DiccionarioString($\alpha$)}, \tadNombre{DiccionarioPrioridad}, \tadNombre{Conjunto Lineal($\alpha$)}


	\InterfazFuncion{CrearJuego}{\In{m}{mapa}}{juego}
	{$res \igobs$ crearJuego(m)}
	[$O(alto(m) \times ancho(m))$]
	[crea un juego vacío usando el mapa provisto.]
	[se guarda una copia de $m$.]

	\InterfazFuncion{AgregarPokémon}{\Inout{j}{juego}, \In{pk}{pokemon}, \In{c}{coor}}{}
	[$j \igobs j_0 \land$ puedoAgregarPokémon($c,j_0$)]
	{$j \igobs$ agregarPokémon($pk, c, j_0$)}
	[$O(|P|)$]
	[agrega un pokemon al juego.]

	\InterfazFuncion{AgregarJugador}{\Inout{j}{juego}}{nat}
	[$j \igobs j_0$]
	{$j \igobs$ agregarJugador($j$)}
	[$O(J)$]
	[registra un nuevo jugador y devuelve su ID.]

	\InterfazFuncion{Conectarse}{\Inout{j}{juego}, \In{e}{jugador}, \In{c}{coor}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego \neg$conectado($e,j_0$) $\land$ posExistente(mapa($j_0$))]
	{$j \igobs$ conectarse($e, c, j_0$)}
	[$O(log(EC))$]
	[conecta al jugador al juego.]

	\InterfazFuncion{Desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego$ conectado($e,j_0$)]
	{$j \igobs$ desconectarse($e, j_0$)}
	[$O(log(EC))$]
	[desconecta al jugador del juego.]

	\InterfazFuncion{Moverse}{\Inout{j}{juego}, \In{e}{jugador}, \In{c}{coor}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego$ conectado($e,j_0$) $\land$ posExistente(c, mapa($j_0$))]
	{$j \igobs$ moverse($e, c, j_0$)}
	[$O((PS + PC)|P| + log(EC))$]
	[mueve el jugador a la posición elegida. Si el movimiento es ilegal, sanciona al jugador o lo expulsa si excede el límite de sanciones. Aumenta los contadores de captura para otros jugadores donde corresponde y puede provocar la captura de pokémons.]

	\InterfazFuncion{Mapa}{\In{j}{juego}}{mapa}
	{alias($res$ = mapa($j$))}
	[$O(1)$]
	[devuelve el mapa del juego.]
	[$res$ no es modificable.]

	\InterfazFuncion{Jugadores}{\In{j}{juego}}{itUni(jugador)}
	{$res \igobs$ crearItUni(jugadores($j$))}
	[$O(1)$]
	[devuelve un iterador del conjunto de jugadores registrados (no expulsados).]
	[el iterador se invalida si se expulsa al siguiente jugador del iterador, o si se agrega un nuevo jugador y el iterador había llegado al final. Además, siguientes($res$) podría cambiar completamente ante cualquier operación que modifique la lista de jugadores.]

	\InterfazFuncion{EstaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ estaConectado($e, j$)}
	[$O(1)$]
	[devuelve si el jugador está conectado al juego.]

	\InterfazFuncion{Sanciones}{\In{j}{juego}, \In{e}{jugador}}{nat}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ sanciones($e, j$)}
	[$O(1)$]
	[devuelve la cantidad de sanciones que el jugador posee.]

	\InterfazFuncion{Posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ posicion($e, j$)}
	[$O(1)$]
	[devuelve la posición actual del jugador.]

	\InterfazFuncion{Pokémons}{\In{j}{juego} \In{e}{jugador}}{itBi(tupla(pokemon, nat))}
	{$res \igobs$ crearItBi($\secuvacia$, pokemons($j$)) $\land$ alias(esPermutacion(SecuSuby($res$), pokemons($j$)))}
	[$O(1)$]
	[devuelve un iterador al conjunto de los pokémons capturados por un jugador, y la cantidad de los mismos.]
	[el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador.]

	\InterfazFuncion{Expulsados}{\In{j}{juego}}{itUni(jugador)}
	{$res \igobs$ crearItUni(expulsados($j$))}
	[$O(1)$]
	[devuelve un iterador del conjunto de jugadores expulsados.]
	[el iterador se invalida si se expulsa al siguiente jugador del iterador, o si se agrega un nuevo jugador y el iterador había llegado al final. Además, siguientes($res$) podría cambiar completamente ante cualquier operación que modifique la lista de jugadores.]

	\InterfazFuncion{PosConPokémons}{\In{j}{juego}}{conj(coor)}
	{alias($res$ = posConPokémons(j))}
	[$O(1)$]
	[devuelve el conjunto de posiciones que contienen un pokémon.]
	[$res$ no es modificable.]

	\InterfazFuncion{PokémonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}
	[$c \in$ posConPokemon($j$)]
	{$res \igobs$ pokémonEnPos($c,j$)}
	[$O(1)$]
	[devuelve el pokémon que se encuentra en la posición.]

	\InterfazFuncion{PuedoAgregarPokémon}{\In{j}{juego}, \In{c}{coor}}{bool}
	{$res \igobs$ puedoAgregarPokémon($c,j$)}
	[$O(PS)$]
	[devuelve si un nuevo pokémon puede ser agregado a esa posición (no debe haber ningún pokémon cerca).]

	\InterfazFuncion{HayPokémonCercano}{\In{j}{juego}, \In{c}{coor}}{bool}
	{$res \igobs$ hayPokémonCercano($c,j$)}
	[$O(PS)$]
	[devuelve si hay algún pokémon cerca de la posición.]

	\InterfazFuncion{PosPokémonCercano}{\In{j}{juego}, \In{c}{coor}}{coor}
	[hayPokémonCercano($c,j$)]
	{$res \igobs$ posPokémonCercano($c,j$)}
	[$O(PS)$]
	[devuelve el pokémon que se encuentra cerca de la posición.]

	\InterfazFuncion{EntrenadoresPosibles}{\In{j}{juego}, \In{c}{coor}}{conj(jugador)}
	[hayPokémonCercano($c,j$)]
	{$res \igobs$ entrenadoresPosibles($c,j$)}
	[$O(EC)$]
	[devuelve el conjunto de jugadores esperando a capturar el pokémon que se encuentra en la posición.]
	[$res$ no es modificable.]

	\InterfazFuncion{IndiceRareza}{\In{j}{juego}, \In{pk}{pokemon}}{nat}
	[$pk \in$ pokemons($j$)]
	{$res \igobs$ indiceRareza($pk,j$)}
	[$O(|P|)$]
	[calcula el índice de rareza de un pokémon.]

	\InterfazFuncion{CantPokémonsTotales}{\In{j}{juego}}{nat}
	{$res \igobs$ cantPokémonsTotales($j$)}
	[$O(1)$]
	[devuelve la cantidad de pokémons en juego.]

	\InterfazFuncion{CantMismaEspecie}{\In{j}{juego}, \In{pk}{pokemon}}{nat}
	[$pk \in$ pokemons($j$)]
	{$res \igobs$ cantMismaEspecie($j$)}
	[$O(|P|)$]
	[devuelve la cantidad de pokémons de la especie especificada en juego.]

	\TituloDis{Operaciones del iterador de jugadores}

	El iterador que presentamos permite recorrer tanto los jugadores registrados válidos como los expulsados de forma unidireccional. El iterador es solo un contador (devuelve las IDs de los jugadores, no su detalle).


	\InterfazFuncion{CrearIt}{\In{j}{juego}, \In{elim?}{bool}}{itJugadores}
	{true}
	[$O(1)$]
	[crea un iterador unidireccional de los jugadores validos o expulsados.]
	[el iterador se invalida si se expulsa al siguiente jugador del iterador, o si se agrega un nuevo jugador y el iterador había llegado al final. Además, siguientes($res$) podría cambiar completamente ante cualquier operación que modifique la lista de jugadores.]

	\InterfazFuncion{HayMas}{\In{it}{itJugadores}}{bool}
	{$res$ $\igobs$ hayMas?($it$)}
	[$O(J)$]
	[devuelve \texttt{true} si y sólo si en el iterador todavía quedan elementos para avanzar.]

	\InterfazFuncion{Actual}{\In{it}{itJugadores}}{jugador}
	[HayMas?($it$)]
	{$res$ $\igobs$ Actual($it$)}
	[$O(J))$]
	[devuelve el elemento siguiente a la posición del iterador.]

	\InterfazFuncion{Avanzar}{\Inout{it}{itJugadores}}{}
	[$it = it_0$ $\land$ HayMas?($it$)]
	{$it$ $\igobs$ Avanzar($it_0$)}
	[$O(J)$]
	[avanza a la posición siguiente del iterador.]
\end{Interfaz}

\begin{Representacion}

	\TituloDis{Representación de Juego}

	\begin{Estructura}{Juego}[pokego]
		\begin{Tupla}[pokego]
			\tupItem{mapa}{mapa}
			\tupItem{pokemons}{diccString(nat)}
			\tupItem{posConPokemons}{conj(coor)}
			\tupItem{\\jugadores}{vector(puntero(infoJugador))}
			\tupItem{\\grillaPos}{arreglo\_dimensionable de (arreglo\_dimensionable de infoPos)}
			\tupItem{\\cantPokemons}{nat}
		\end{Tupla}

		\begin{Tupla}[infoJugador]
			\tupItem{sanciones}{nat}
			\tupItem{conectado?}{bool}
			\tupItem{posicion}{coor}
			\tupItem{cantPokemons}{nat}
			\tupItem{\\pokemonsCapturados}{diccString(nat)}
		\end{Tupla}

		\begin{Tupla}[infoPos]
			\tupItem{hayPokemon?}{bool}
			\tupItem{pokemon}{pokemon}
			\tupItem{contadorCaptura}{nat}
			\tupItem{jugEsperandoCaptura}{dicPrior}
			\tupItem{jugsEnPos}{conjJugs}
		\end{Tupla}

	\end{Estructura}
	
	\TituloDis{Invariante de Representación del Juego}

	\begin{enumerate}

		\item La grilla tiene el alto y ancho del mapa %DONE

		\item Los jugadores conectados estan en la grilla en la posicion en la que se encuentra %DONE

		\item En los jugadores que se encutuentran en la grilla solo estan los que realmente se encuentran ahi

		\item Solo las posiciones con pokemon tienen pokemons en la grilla

		\item Los significados del diccionario de pokemons es igual a la cantidad de pokemons que hay capturados mas los salvajes

		\item CantPokemons es igual a la suma de todas los significados del diccionario

		\item Los jugadores tienen menos de 5 sanciones


		%THE OLD ONE
		\item Todas las coordenadas pertenecientes a posConPokemons pertenecen a las coordenadas válidas del mapa

		\item La suma de todos los significados del diccionario pokemons es igual a cantPokemons
		
		\item No hay dos coordenadas pertenecientes a posConPokemons a menos de 5 de distancia
		
		\item Para cada miembro de jugadores, las claves de pokemonsCapturados pertenecen a las claves de pokemons

		\item Para cada clave de pokemons, su significado es la suma de:
		\begin{itemize}
			\item todos los significados de esa misma clave en los pokemonsCapturados de cada miembro de jugadores donde la clave existe y el jugador no fue eliminado
			\item la cantidad de coordenadas de posConPokemons donde se encuentra un pokemon igual a esa clave
		\end{itemize}

		\item Para cada coordenada de posConPokemons, la coordenada corespondiente en la grilla almacena el pokémon que se encuentra ahí
		
		\item Para cada miembro de jugadores, si el jugador esta conectado su posición tiene que pertenecer a las coordenadas válidas del mapa
		
	\end{enumerate}


	\Rep[pokego][e]{

		long(e.grillaPos) = alto(e.mapa) $\yluego$\\
		(($\forall n$: nat) n $\leq$ alto(e.mapa) $\implies$ long(e.grillaPos[n]) = ancho(e.mapa)) $\yluego$\\
		jugadoresConectadosEstanEnLaPos(e) $\land$\\






		($\forall c$: coor)(c $\in$ e.posConPokemons $\implies$ (c $\in$ coordenadas(e.mapa) $\yluego$ pokeEnGrilla(e, c))) \\
		$\land$ e.cantPokemons = sumaSignificadosPoke(claves(e.pokemons), e.pokemons) $\land$ ($\forall c,d$: coor) \\
		(c $\in$ e.posConPokemons $\land$ d $\in$ e.posConPokemons $\implies$ c = d $\lor$ distEuclidea(c,d) $>$ 25) $\land$ \\
		($\forall i$:nat)(i $<$ long(e.jugadores) $\implies$ claves(e.jugadores[i]$\rightarrow$pokemonsCapturados) $\subseteq$ claves(e.pokemons)) \\
		$\land$ ($\forall i$:nat)((i $<$ long(e.jugadores) $\yluego$ (e.jugadores[i]$\rightarrow$sanciones $<$ 5 $\land$ e.jugadores[i]$\rightarrow$conectado)) $\implies$ \\
		e.jugadores[i]$\rightarrow$posicion $\in$ coordenadas(e.mapa))
	}
	


	\tadAxioma{jugadoresConectadosEnPosValidas(e)}{
		($\forall i$: nat) ((i $\leq$ long(e.jugadores) $\land$ e.jugadores[i]$\rightarrow$conectado?)$\implies$(posExistente(e.jugadores[i]$\rightarrow$posicion, e.mapa)))
	}

	\tadAxioma{jugadoresConectadosEstanEnLaPos(e)}{
		($\forall i$: nat) ((i $\leq$ long(e.jugadores) $\land$ e.jugadores[i]$\rightarrow$conectado?)$\implies$(i $\in$ e.grillaPos[longitud(e.jugadores[i]$\rightarrow$posicion)][latitud(e.jugadores[i]$\rightarrow$posicion)].jugsEnPos))
	}

	\tadAxioma{jugaresEnPosEstanConectados(e)}{
		($\forall c$: coor) posExistente(c, e.mapa) $\implies$ e.grillaPos[longitud(c)][latitud(c)].jugsEnPos $\subseteq$ jugadoresConectadosAux(e.jugadores)
	}

	\tadAxioma{jugadoresConectadosAux(js)}{
		\IF vacia?(js) THEN
			\secuvacia
		ELSE
			{\IF prim(js).conectado? THEN
				Ag(prim(js), jugadoresConectadosAux(fin(js))) %%ESTO DEBERIA SER UN JUGADOR PERO CHUPENLA
			ELSE
				jugadoresConectadosAux(fin(js))
			FI}
		FI
	}




	~
	
	\tadOperacion{pokeEnGrilla}{pokego/e, coor/c}{bool}{c $\in$ coordenadas(e.mapa)}
	\tadAxioma{pokeEnGrilla(j, c)}{e.grilla[latitud(c)][longitud(c)].hayPokemon}

	~
	
	\tadOperacion{sumaSignificadosPoke}{conj(pokemon)/cs, dicc(String{,}Nat)/dic}{nat}{cs $\subseteq$ claves(dic)}
	\tadAxioma{sumaSignificadosPoke(cs, dic)}
	{\IF vacia?(cs) THEN
		0
	ELSE
		obtener(dic, dameUno(cs)) + sumaSignificadosPoke(sinUno(cs), dic)
	FI}
		
	~
	
	\TituloDis{Función de Abstracción}

	\Abs[pokego]{juego}[e]{j}{
		mapa(j) = e.mapa $\land$ long(e.jugadores) = ProxID(j) $\yluego$ ($\forall p:$ jugador) \\
		(long(e.jugadores) $>$ p $\impluego$ (sanciones(p, j) = e.jugadores[p]$\rightarrow$sanciones $\land$ \\
		sanciones(p, j) $<$ 5 $\impluego$ (j $\in$ jugadores(j) $\yluego$ estaConectado(p, j) = e.jugadores[p]$\rightarrow$conectado? \\
		$\land$ (estaConectado(p, j) $\impluego$ posicion(p, j) = e.jugadores[p]$\rightarrow$posicion) $\land$ \\
		pokemons(j) = listaPoke(claves(e.pokemons), e.pokemons)) $\land$ \\
		(e.jugadores[p]$\rightarrow$sanciones = 5) = (p $\in$ expulsados(j)))) $\land$ ($\forall c:$ coor) \\
		(c $\in$ posConPokemons(j) = c $\in$ e.posConPokemons $\yluego$ c $\in$ posConPokemons(j) $\impluego$ (pokemonEnPos(c, j) = j.grillaPos[Latitud(c)][Longitud(c)].pokemon $\land$ cantMovimientosParaCaptura(c, j) = j.grillaPos[Latitud(c)][Longitud(c)].contadorCaptura))
	}
	
	~

	\tadOperacion{listaPoke}{conj(pokemon)/cs, dicc(String{,}Nat)/dic}{multiconj(pokemon)}{cs $\subseteq$ claves(dic)}
	\tadOperacion{agregarPoke}{pokemon, nat}{multiconj(pokemon)}{}
		 
	~

	\tadAxioma{listasPoke(cs, dic)}
	{\IF vacia?(cs) THEN
		$\emptyset$
	ELSE
		agregarPoke(dameUno(cs),obtener(dameUno(cs),dic)) $\bigcup$ listasPoke(sinUno(cs), dic)
	FI}
		
	~

	\tadAxioma{agregarPoke(p, n)}
	{\IF n = 0 THEN
		$\emptyset$
	ELSE
		Ag(p, agregarPoke(p, n-1))
	FI}


	\TituloDis{Representación del iterador de jugadores}

	\begin{Estructura}{itJugadores}[itJug]
		\begin{Tupla}[itJug]
			\tupItem{listaJugadores}{puntero(vector(puntero(infoJugador)))}
			\tupItem{contador}{nat}
			\tupItem{\\eliminados?}{bool}
		\end{Tupla}
	\end{Estructura}

	\TituloDis{Invariante de Representación del iterador}

	\begin{enumerate}

		\item La lista de jugadores no es nula

	\end{enumerate}

	\Rep[itJug][it]{it.listaJugadores $\neq$ NULL}


	\TituloDis{Función de Abstracción del iterador}

	\Abs[itJug]{itUni(nat)}[it]{b}{Siguientes(b) $=$ seleccionar(ultimos(*it.listaJugadores, it.contador), it.eliminados?)}

	~

	\tadOperacion{selecionar}{secu(infoJugador)/js,  bool/elim?}{secu(nat)}{}

	\tadOperacion{ultimos}{secu(infoJugador)/js,  nat/n}{secu(infoJugador)}{}

	~

	\tadAxioma{selecionar(js, elim?)}
	{\IF vacia?(js) THEN
		\secuvacia
	ELSE
		{\IF (ult(js).sanciones $<$ 5) = elim? THEN  seleccionar(com(js), elim?) \circulito (long(js) - 1)) ELSE seleccionar(com(js), elim?) FI}
	FI}

	\tadAxioma{ultimos(js, n)}
	{\IF 0?(n) $\lor$ vacia?(js) THEN
		\secuvacia
	ELSE
		ultimos(com(js), n-1) \circulito ult(js)
	FI}
\end{Representacion}

\begin{Algoritmos}

	\TituloDis{Algoritmos de Juego}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iCrearJuego}{\In{m}{mapa}}{pokego}}
		res.mapa $\leftarrow$ m\OdeLinea{1}
		res.pokemons $\leftarrow$ CrearDiccionario()\OdeLinea{1}
		res.posConPokemons $\leftarrow$ Vacio()\OdeLinea{1}
		res.jugadores $\leftarrow$ Vacio()\OdeLinea{1}
		res.cantPokemons $\leftarrow$ 0\OdeLinea{1}
		res.grillaPos $\leftarrow$ CrearArreglo(Alto(m))\OdeLinea{Alto(m)}
		\For(\OdeBloque{Alto(m) \times Ancho(m)}){$i \leftarrow 0$ \KwTo Alto($m$)}{
			res.grillaPos[i] $\leftarrow$ CrearArreglo(Ancho(m))\OdeLinea{Ancho(m)}
			\For(\OdeBloque{Ancho(m)}){$j \leftarrow 0$ \KwTo Ancho($m$)}{
				res.grillaPos[i][j] $\leftarrow$ CrearInfoPos()\OdeLinea{1}
			}
		}
	\end{algorithm}

	\complejidad: $O(Alto(m) \times Ancho(m))$

	\justifcomp: se debe reservar memoria para la grilla que contiene información del juego de cada posición.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iAgregarPokémon}{\Inout{j}{pokego}, \In{pk}{pokemon}, \In{c}{coor}}{}}
		j.cantPokemons $\leftarrow$ j.cantPokemons + 1\OdeLinea{1}
		\eIf{Definido(j.pokemons, pk)}{
			nat: nuevaCant $\leftarrow$ Obtener(j.pokemons, pk) + 1\OdeLinea{|pk|}
			Definir(j.pokemons, pk, nuevaCant)\OdeLinea{|pk|}
		}{
			Definir(j.pokemons, pk, 1)\OdeLinea{|pk|}
		}

		j.grillaPos[Latitud(c)][Longitud(c)].hayPokemon $\leftarrow$ true\OdeLinea{1}
		j.grillaPos[Latitud(c)][Longitud(c)].pokemon $\leftarrow$ pk\OdeLinea{1}
		j.grillaPos[Latitud(c)][Longitud(c)].contadorCaptura $\leftarrow$ 0\OdeLinea{1}
		\tcc{Se desestima la complejidad de borrar el diccionario de prioridad anterior}
		j.grillaPos[Latitud(c)][Longitud(c)].jugEsperandoCaptura $\leftarrow$ Vacio()\OdeLinea{1}

		conj(coor) : coorEnRango $\leftarrow$ PosicionesEnRango(j, c, 2)\OdeLinea{1}
		itBi(coor) : itCoor $\leftarrow$ CrearIt(coorEnRango)\OdeLinea{1}
		\While(\OdeBloque{EC \times log(EC)}){HaySiguiente(itCoor)}{
			coor: d $\leftarrow$ Siguiente(itCoor)\OdeLinea{1}

			itUni(Jugador) : it $\leftarrow$ CrearIterador(j.grillaPos[Latitud(d)][Longitud(d)].jugsEnPos)\OdeLinea{1}
			\While(\OdeBloque{EC \times log(EC)}){HayMas(it)}{
				jugador: jug $\leftarrow$ Actual(it)\OdeLinea{1}
				Definir(j.grillaPos[Latitud(c)][Longitud(c)].jugEsperandoCaptura, jug, (*j.jugadores[jug]).cantPokemons)\OdeLinea{log(EC)}
				Avanzar(it)\OdeLinea{1}
			}
			Avanzar(itCoor)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(|P| + EC \times log(EC))$

	\justifcomp: todos los jugadores que se encuentran en el area (EC) deben agregarse a la lista de espera, que los ordena por prioridad (inserción en log(EC)). Al mismo tiempo debe definirse este nuevo pokémon en el diccionario global ($|P|$).

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iAgregarJugador}{\Inout{j}{pokego}}{nat}}
		res $\leftarrow$ Longitud(j.jugadores)\OdeLinea{1}
		AgregarAtras(j.jugadores, CrearInfoJugador())\OdeLinea{J}
	\end{algorithm}

	\complejidad: $O(J)$

	\justifcomp: en el peor caso se debe redimensionar el vector. Hacerlo requiere copiar el arreglo interno, pero al tratarse de punteros la copia es gratuita ($\Theta(1)$ por posición, o $\Theta(J)$ en su totalidad).

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iConectarse}{\Inout{j}{pokego}, \In{e}{jugador}, \In{c}{coor}}{}}
		(*j.jugadores[e]).conectado? $\leftarrow$ true\OdeLinea{1}
		(*j.jugadores[e]).posicion $\leftarrow$ c\OdeLinea{1}
		Agregar(j.grillaPos[Latitud(c)][Longitud(c)].jugsEnPos, e)\OdeLinea{log(EC)}
		AgregarACola(j, e)\OdeLinea{log(EC)}
		ResetearContadores(j, e)\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(log(EC))$

	\justifcomp: al conectarse, el jugador debe agregarse al conjunto de jugadores en $c$, y unirse a la cola de espera de captura de haber un pokemón cerca. De ser ese el caso, la cantidad de jugadores en la cola de espera será siempre mayor a la cantidad de jugadores en $c$ (todos los jugadores en $c$ están en la cola de espera).

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iDesconectarse}{\Inout{j}{pokego}, \In{e}{jugador}}{}}
		(*j.jugadores[e]).conectado? $\leftarrow$ false\OdeLinea{1}
		Borrar(j.grillaPos[Latitud(c)][Longitud(c)].jugsEnPos, e)\OdeLinea{log(EC)}
		RemoverDeCola(j, e)\OdeLinea{log(EC)}
	\end{algorithm}

	\complejidad: $O(log(EC))$

	\justifcomp: inversamente, al desconectarse, el jugador debe salir del conjunto de jugadores en $c$ y de la cola de espera de captura (de haber un pokemón cerca).

	~

	\begin{algorithm}[H] 
		\NoCaptionOfAlgo
		\caption{\algoritmo{iMoverse}{\Inout{j}{pokego}, \In{e}{jugador}, \In{c}{coor}}{}}
		coor : posAnterior $\leftarrow$ Posicion(j,e)\OdeLinea{1}
		\tcc{Removemos al jugador del conjunto de su posición anterior y de 	la cola de espera}
		Borrar(j.grillaPos[Latitud(c)][Longitud(c)].jugsEnPos, e)\OdeLinea{log(EC)}
		RemoverDeCola(j, e)\OdeLinea{log(EC)}
		\If{\textbf{not} HayCamino(j.mapa, posAnterior, c) \textbf{or} DistEuclidea(posAnterior, c) $>$ 100}{
			(*j.jugadores[e]).sanciones $\leftarrow$ (*j.jugadores[e]).sanciones + 1\OdeLinea{1}
		}
		\eIf{(*j.jugadores[e]).sanciones = 5}{
			\tcc{Si el jugador debe ser eliminado, borramos sus pokémons}
			itDiccString(nat) : pokesABorrar $\leftarrow$ CrearIt((*j.jugadores[e]).pokemonsCapturados)\OdeLinea{1}
			\While(\OdeBloque{PC \times |P|}){HaySiguiente(pokesABorrar)}{
				tupla(calve: String, significado: Nat) : sig $\leftarrow$ Siguiente(pokesABorrar)\OdeLinea{|P|}

				nat: nuevaCant $\leftarrow$ Obtener(j.pokemons, sig.clave) - sig.significado\OdeLinea{|P|}
				Definir(j.pokemons, pk, nuevaCant)\OdeLinea{|P|}
				j.cantPokemons $\leftarrow$ j.cantPokemons - sig.significado\OdeLinea{1}
			}
		}{
			\tcc{Si el jugador sigue siendo válido, lo agregamos al conjunto de su nueva posición y a la cola de espera}
			(*j.jugadores[e]).posicion $\leftarrow$ c\OdeLinea{1}
			AgregarACola(j, e, c)\OdeLinea{log(EC)}
			Agregar(j.grillaPos[Latitud(c)][Longitud(c)].jugsEnPos, e)\OdeLinea{log(EC)}
		}

		it $\leftarrow$ CrearIt(j.posConPokemons)\OdeLinea{1}
		\tcc{Iteramos las posiciones con pokémons}
		\tcc{Iteramos las posiciones con pokémons}
		\While(\OdeBloque{PS \times |P|}){HaySiguiente?(it)}{
			coor: coorConPk $\leftarrow$ Siguiente(it)\OdeLinea{1}
			\eIf{DistEuclidea(c, coorConPk) $>$ 4}{
				\tcc{Si el movimiento es lejano, sumar al contador e manejar captura si corresponde}
				j.grillaPos[Latitud(coorConPk)][Longitud(coorConPk)].contadorCaptura $\leftarrow$ j.grillaPos[Latitud(coorConPk)][Longitud(coorConPk)].contadorCaptura +1\OdeLinea{1}
				infoPos: posPk $\leftarrow$ j.grillaPos[Latitud(coorConPk)][Longitud(coorConPk)]\OdeLinea{1}
				\eIf{posPk.contadorCaptura = 10  \textbf{and not} esVacio?(posPk.jugEsperandoCaptura)}{
					pokemon: pk $\leftarrow$ posPk.pokemon\OdeLinea{1}
					jugador: captor $\leftarrow$ Menor(posPk.jugEsperandoCaptura)\OdeLinea{1}
					(*j.jugadores[captor]).cantPokemons $\leftarrow$ (*j.jugadores[captor]).cantPokemons + 1\OdeLinea{1}
					\eIf(\OdeBloque{log(|P|)}){Definido((*j.jugadores[captor]).pokemonsCapturados, pk)}{
						nat: nuevaCant $\leftarrow$ Obtener((*j.jugadores[captor]).pokemonsCapturados, pk) + 1\OdeLinea{log(|P|)}
						Definir((*j.jugadores[captor]).pokemonsCapturados, pk, nuevaCant)\OdeLinea{log(|P|)}
					}{
						Definir((*j.jugadores[captor]).pokemonsCapturados, pk, 1)\OdeLinea{log(|P|)}
					}

					\tcc{Si se elimina esa posición, no hay que avanzar el iterador}
					EliminarSiguiente(it)\OdeLinea{1}
				}{
					Avanzar(it)\OdeLinea{1}
				}
			}{
				\If{DistEuclidea(posAnterior, coorConPk) $>$ 4}{
					\tcc{Si el jugador entró a una nueva área de captura, reiniciar el contador}
					j.grillaPos[Latitud(coorConPk)][Longitud(coorConPk)].contadorCaptura $\leftarrow$ 0\OdeLinea{1}
				}
				Avanzar(it)\OdeLinea{1}
			}
		}
	\end{algorithm}

	\complejidad: $O((PS + PC) \times |P| + log(EC))$

	\justifcomp: las validaciones del movimiento son gratuitas gracias a la implementación por grupos de mapa. Por otro lado, si el jugador queda eliminado, debe eliminarse del diccionario del sistema ($|P|$) cada pokémon que había capturado (PC).

	En cada movimiento, el jugador que se mueve debe cambiar de conjunto y tal vez salir de o entrar en un grupo de espera de captura de un pokémon (log(EC)).

	Por otro lado, para posiciones lejanas se deben procesarse las potenciales capturas (PS), agregando el pokémon al diccionario del jugador que lo captura ($|P|$).

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iMapa}{\In{j}{pokego}}{mapa}}
		res $\leftarrow$ j.mapa\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: se devuelve el mapa por referencia.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPokémonEnPos}{\In{j}{pokego}, \In{c}{coor}}{pokemon}}
		res $\leftarrow$ j.grillaPos[Latitud(c)][Longitud(c)].pokemon\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iEstaConectado}{\In{j}{pokego}, \In{e}{jugador}}{bool}}
		res $\leftarrow$ (*j.jugadores[e]).conectado?\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iSanciones}{\In{j}{pokego}, \In{e}{jugador}}{nat}}
		res $\leftarrow$ (*j.jugadores[e]).sanciones\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se accede a un vector y se desreferncia un puntero y/o se accede a un miembro.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPosicion}{\In{j}{pokego}, \In{e}{jugador}}{coor}}
		res $\leftarrow$ CrearCoor(Latitud((*j.jugadores[e]).posicion), Longitud((*j.jugadores[e]).posicion))\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se accede a un vector, se desreferencia un puntero y se crea una copia de la coordenada.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPokémons}{\In{j}{pokego}, \In{e}{jugador}}{itBi(tupla(pokemon, nat))}}
		res $\leftarrow$ CrearIterador((*j.jugadores[e]).pokemonsCapturados)\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iJugadores}{\In{j}{pokego}}{itJugadores}}
		res $\leftarrow$ CrearIt(j, false)\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iExpulsados}{\In{j}{pokego}}{itJugadores}}
		res $\leftarrow$ CrearIt(j, true)\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializa el iterador. 

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPosConPokémons}{\In{j}{pokego}}{conj(coor)}}
		res $\leftarrow$ j.posConPokemons\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se devuelve el conjunto por referencia.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPuedoAgregarPokémon}{\In{j}{pokego}, \In{c}{coor}}{bool}}
		res $\leftarrow$ PosExistente(j.mapa, c) \textbf{and} HayPokémonEnDistancia(j, c, 5)\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iHayPokémonCercano}{\In{j}{pokego}, \In{c}{coor}}{bool}}
		res $\leftarrow$ HayPokémonEnDistancia(j, c, 2)\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iPosPokémonCercano}{\In{j}{pokego}, \In{c}{coor}}{coor}}
		conj(coor) : coorEnRango $\leftarrow$ PosicionesEnRango(j, c, 2)\OdeLinea{1}
		itBi(coor) : itCoor $\leftarrow$ CrearIt(coorEnRango)\OdeLinea{1}
		\While(\OdeBloque{n^2}){HaySiguiente(itCoor)}{
			coor : siguiente $\leftarrow$ Siguiente(itCoor)\OdeLinea{1}
			\If{HayPokémonEnPos(j, siguiente) $\leq$ n}{
				res $\leftarrow$ siguiente\OdeLinea{1}
			}
			Avanzar(itCoor)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo debe iterar todas las posiciones de un cuadrado de lado predeterminado. Al ser predeterminado se considera constante.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iEntrenadoresPosibles}{\In{j}{pokego}, \In{c}{coor}}{conj(jugador)}}
		res $\leftarrow$ Claves(j.grillaPos[Latitud(c)][Longitud(c)].jugEsperandoCaptura)
	\end{algorithm}

	\complejidad: $O(EC)$

	\justifcomp: el diccionario debe recuperar las claves iterando.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iCantPokémonsTotales}{\In{j}{pokego}}{nat}}
		res $\leftarrow$ j.cantPokemons\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se retorna un valor almacenado.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iIndiceRareza}{\In{j}{pokego}, \In{pk}{pokemon}}{nat}}
		nat : cantPk $\leftarrow$ CantMismaEspecie(j, pk)\OdeLinea{|P|}
		res $\leftarrow$ 100 - (cantPk $\times$ 100 $\div$ j.cantPokemons)\OdeLinea{1}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{iCantMismaEspecie}{\In{j}{pokego}, \In{pk}{pokemon}}{nat}}
		res $\leftarrow$ Obtener(j.pokemones, pk)\OdeLinea{|P|}
	\end{algorithm}

	\complejidad: $O(|P|)$

	\justifcomp: se debe acceder al diccionario para averiguar cuántos pokemons de esa especie.


	\TituloDis{Algoritmos auxiliares}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearInfoPos}{}{infoPos}}
		\Pre{\texttt{true}}
		\Post{la posición nueva no contiene pokémon ni jugadores}
		\BlankLine
		res.hayPokemon? $\leftarrow$ false\OdeLinea{1}
		res.contadorCaptura $\leftarrow$ 0\OdeLinea{1}
		res.jugEsperandoCaptura $\leftarrow$ Vacio()\OdeLinea{1}
		res.jugsEnPos $\leftarrow$ Vacio()\OdeLinea{1}
	\end{algorithm}
	
	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearInfoJugador}{}{puntero(infoJugador)}}
		\Pre{\texttt{true}}
		\Post{el jugador nuevo no tiene sanciones ni pokémons y no está conectado}
		\BlankLine
		infoJugador : nuevo\OdeLinea{1}
		nuevo.sanciones $\leftarrow$ 0\OdeLinea{1}
		nuevo.conectado? $\leftarrow$ false\OdeLinea{1}
		nuevo.cantPokemons $\leftarrow$ 0\OdeLinea{1}
		nuevo.pokemonsCapturados $\leftarrow$ CrearDiccionario()\OdeLinea{1}
		res $\leftarrow$ \&nuevo\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializan las variables.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{AgregarACola}{\Inout{j}{pokego}, \In{e}{jugador}}{}}
		\Pre{$e \in$ jugadores($j$) $\yluego$ conectado?(e, j)}
		\Post{agrega al jugador a la lista de espera del pokémon mas cercano a él (si hay uno en rango de captura)}
		\BlankLine
		coor: c $\leftarrow$ (*j.jugadores[e]).posicion\OdeLinea{1}
		conj(coor) : coorEnRango $\leftarrow$ PosicionesEnRango(j, c, 2)\OdeLinea{1}
		itBi(coor) : itCoor $\leftarrow$ CrearIt(coorEnRango)\OdeLinea{1}
		\While(\OdeBloque{log(EC)}){HaySiguiente(itCoor)}{
			coor: siguiente $\leftarrow$ Siguiente(itCoor)\OdeLinea{1}
			\If{HayPokémonEnPos(j, siguiente).hayPokemon}{
				Definir(j.grillaPos[Latitud(siguiente)][Longitud(siguiente)].jugEsperandoCaptura, (*j.jugadores[e]).cantPokemons)\OdeLinea{log(EC)}
			}
			Avanzar(itCoor)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(log(EC))$

	\justifcomp: el algoritmo recorre una cantidad menor a una constante de coordenadas alrededor del jugador, de encontrar un Pokemon, agrega al jugador al diccionarioDePrioridad que tiene insercion en $O(log(EC))$, ademas por la especificacion sabemos que un jugador puede estar capturando un solo pokemon, por lo que definir el jugador se hace una vez.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{RemoverDeCola}{\Inout{j}{pokego}, \In{e}{jugador}}{}}
		\Pre{$e \in$ jugadores($j$) $\yluego$ conectado?(e, j)}
		\Post{remueve al jugador de la lista de espera del pokémon mas cercano a él (si hay uno en rango de captura)}
		\BlankLine
		coor: c $\leftarrow$ (*j.jugadores[e]).posicion\OdeLinea{1}
		conj(coor) : coorEnRango $\leftarrow$ PosicionesEnRango(j, c, 2)\OdeLinea{1}
		itBi(coor) : itCoor $\leftarrow$ CrearIt(coorEnRango)\OdeLinea{1}
		\While(\OdeBloque{log(EC)}){HaySiguiente(itCoor)}{
			coor: siguiente $\leftarrow$ Siguiente(itCoor)\OdeLinea{1}
			\If{HayPokémonEnPos(j, siguiente).hayPokemon}{
				Borrar(j.grillaPos[Latitud(siguiente)][Longitud(siguiente)].jugEsperandoCaptura, e)\OdeLinea{log(EC)}
			}
			Avanzar(itCoor)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(log(EC))$

	\justifcomp: debe iterar todas las posiciones de un cuadrado de lado predeterminado y agregar al jugador a la cola de espera de captura más cercana. Si la misma existe.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{ResetearContadores}{\Inout{j}{pokego}, \In{e}{jugador}}{}}
		\Pre{$e \in$ jugadores($j$) $\yluego$ conectado?(e, j)}
		\Post{los contadores de captura las posiciones aledañas al jugador vuelven a 0}
		\BlankLine
		coor: c $\leftarrow$ (*j.jugadores[e]).posicion\OdeLinea{1}
		conj(coor) : coorEnRango $\leftarrow$ PosicionesEnRango(j, c, 2)\OdeLinea{1}
		itBi(coor) : itCoor $\leftarrow$ CrearIt(coorEnRango)\OdeLinea{1}
		\While(\OdeBloque{1}){HaySiguiente(itCoor)}{
			coor: siguiente $\leftarrow$ Siguiente(itCoor)\OdeLinea{1}
			\If{HayPokémonEnPos(j, siguiente).hayPokemon}{
				j.grillaPos[Latitud(siguiente)][Longitud(siguiente)].contadorCaptura $\leftarrow$ 0\OdeLinea{1}
			}
			Avanzar(itCoor)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: debe iterar todas las posiciones de un cuadrado de lado predeterminado.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{PosicionesEnRango}{\Inout{j}{pokego}, \In{c}{coor, \In{n}{nat}}}{conj(coor)}}
		\Pre{\texttt{true}}
		\Post{res es igual al conjunto de posiciones válidas cerca de $c$, con distancia euclidiana máxima de $n^2$.\footnotemark{}}
		\BlankLine
		res $\leftarrow$ Vacia()\OdeLinea{1}
		\For(\OdeBloque{n^2}){$i \leftarrow 0$ \KwTo $n$}{
			\For(\OdeBloque{n}){$j \leftarrow 0$ \KwTo $n$}{
				coor : ne $\leftarrow$ CrearCoor(Latitud(c) + i, Longitud(c) + j)\OdeLinea{1}
				\If(\OdeBloque{1}){DistEuclidea(c,ne) $\leq n^2$ \textbf{and} PosExistente(ne, j.mapa)}{
						AgregarRapido(res, ne)\OdeLinea{1}
				}
				\If{Longitud(c) $>$ j}{
					coor : no $\leftarrow$ CrearCoor(Latitud(c) + i, Longitud(c) - j)\OdeLinea{1}
					\If(\OdeBloque{1}){DistEuclidea(c,no) $\leq n^2$ \textbf{and} PosExistente(no, j.mapa)}{
						AgregarRapido(res, no)\OdeLinea{1}
					}
				}
				\If{Latitud(c) $>$ i}{
					coor : se $\leftarrow$ CrearCoor(Latitud(c) - i, Longitud(c) + j)\OdeLinea{1}
					\If(\OdeBloque{1}){DistEuclidea(c,se) $\leq n^2$ \textbf{and} PosExistente(se, j.mapa)}{
						AgregarRapido(res, se)\OdeLinea{1}
					}
				}
				\If{Latitud(c) $>$ i \textbf{and} Longitud(c) $>$ j}{
					coor : so $\leftarrow$ CrearCoor(Latitud(c) - i, Longitud(c) - j)\OdeLinea{1}
					\If(\OdeBloque{1}){DistEuclidea(c,so) $\leq n^2$ \textbf{and} PosExistente(so, j.mapa)}{
						AgregarRapido(res, so)\OdeLinea{1}
					}
				}
			}
		}
	\end{algorithm}

	\footnotetext{Se usa la definición de Coordenada de distancia euclidiana, que no implica la raíz cuadrada.}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{HayPokémonEnDistancia}{\In{j}{pokego}, \In{c}{coor}, \In{n}{nat}}{bool}}
		\Pre{\texttt{true}}
		\Post{res es \texttt{true} si hay un pokémon en una posición en el conjunto de posiciones válidas cerca de $c$, con distancia euclidiana máxima de $n^2$.}
		\BlankLine
		res $\leftarrow$ false\OdeLinea{1}
		conj(coor) : coorEnRango $\leftarrow$ PosicionesEnRango(j, c, n)\OdeLinea{1}
		itBi(coor) : itCoor $\leftarrow$ CrearIt(coorEnRango)\OdeLinea{1}
		\While(\OdeBloque{n^2}){HaySiguiente(itCoor)}{
			coor : siguiente $\leftarrow$ Siguiente(itCoor)\OdeLinea{1}
			\If{HayPokémonEnPos(j, siguiente) $\leq$ n}{
				res $\leftarrow$ true\OdeLinea{1}
			}
			Avanzar(itCoor)\OdeLinea{1}
		}
	\end{algorithm}

	\complejidad: $O(n^2)$

	\justifcomp: itera n veces por latitud, multiplicado por n veces por la longitud.

	
	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{HayPokémonEnPos}{\Inout{j}{pokego}, \In{c}{coor}}{bool}}
		\Pre{posExistente(c, mapa($j$))}
		\Post{res $\igobs$ c $\in$ posConPokémons(j)}
		\BlankLine
		res $\leftarrow$ j.grillaPos[Latitud(c)][Longitud(c)].hayPokemon\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se accede al arreglo.

	\TituloDis{Algoritmos del iterador}

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{CrearIt}{\In{j}{pokego}, \In{elim?}{bool}}{itJugadores}}
		res.listaJugadores $\leftarrow$ \&(j.jugadores)\OdeLinea{1}
		res.contador $\leftarrow$ 0\OdeLinea{1}
		res.eliminados $\leftarrow$ elim?\OdeLinea{1}
	\end{algorithm}

	\complejidad: $O(1)$

	\justifcomp: solo se inicializa el iterador.

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{HayMas}{\In{it}{itJugadores}}{bool}}
		res $\leftarrow$ false\OdeLinea{1}
		\For(\OdeBloque{J}){$i \leftarrow$ it.contador \KwTo long(*it.listaJugadores)}{
			\If{((*it.listaJugadores)[i].sanciones $<5$) = it.eliminados?}{
				res $\leftarrow$ true\OdeLinea{1}
				\textbf{break}\;
			}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Actual}{\In{it}{itJugadores}}{jugador}}
		\For(\OdeBloque{J}){$i \leftarrow$ it.contador \KwTo long(*it.listaJugadores)}{
			\If{((*it.listaJugadores)[i].sanciones $<5$) = it.eliminados?}{
				res $\leftarrow$ i\OdeLinea{1}
				\textbf{break}\;
			}
		}
	\end{algorithm}

	~

	\begin{algorithm}[H]
		\NoCaptionOfAlgo
		\caption{\algoritmo{Avanzar}{\Inout{it}{itJugadores}}{}}
		\For(\OdeBloque{J}){$i \leftarrow$ it.contador \KwTo long(*it.listaJugadores)}{
			\If{((*it.listaJugadores)[i].sanciones $<5$) = it.eliminados?}{
				it.contador $\leftarrow$ i + 1\OdeLinea{1}
				\textbf{break}\;
			}
		}
	\end{algorithm}

	\complejidad: $O(J)$

	\justifcomp: como la lista de jugadores y la de eliminados son la misma, debe iterarla en su totalidad hasta encontrar otro elemento válido (si es que existe).

	Cabe aclarar que la complejidad de iterar la lista en su totalidad es $\Theta(J)$, ya que la parte de la lista que se debe iterar en cada iteración es distinta, hasta que se la recorre de manera completa.

\end{Algoritmos}
