\section{Módulo Juego}

La cantidad de cada pokémon se guarda en un diccionario basado en trie, usando los nombres como claves. Sus posiciones se guardan en un Conjunto Lineal con inserción rápida, y en el mismo mapa se guarda el pokémon que se ubica en dicha posición (este valor se invalida si la posición no está en el conjunto, como cuando se captura el pokémon). 

\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Juego}.

	\textbf{géneros}: \TipoVariable{juego}.

	\textbf{servicios usados}: \tadNombre{Vector($\alpha$)}, \tadNombre{DiccionarioString($\alpha$)}, \tadNombre{Conjunto Lineal($\alpha$)}


	\InterfazFuncion{CrearJuego}{\In{m}{mapa}}{juego}
	{$res \igobs$ crearJuego(m)}
	[$O()$]
	[crea un juego vacío usando el mapa provisto.]
	[se guarda una copia de $m$.]

	\InterfazFuncion{AgregarPokémon}{\Inout{j}{juego}, \In{pk}{pokemon}, \In{c}{coor}}{}
	[$j \igobs j_0 \land$ puedoAgregarPokémon($c,j_0$)]
	{$j \igobs$ agregarPokémon($pk, c, j_0$)}
	[$O(|pk_{max}|)$]
	[agrega un pokemon al juego.]

	\InterfazFuncion{AgregarJugador}{\Inout{j}{juego}}{nat}
	[$j \igobs j_0$]
	{$j \igobs$ agregarJugador($j$)}
	[$O()$]
	[registra un nuevo jugador y devuelve su ID.]

	\InterfazFuncion{Conectarse}{\Inout{j}{juego}, \In{e}{jugador}, \In{c}{coor}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego \neg$conectado($e,j_0$) $\land$ posExistente(mapa($j_0$))]
	{$j \igobs$ conectarse($e, c, j_0$)}
	[$O(log(\#Jugadores(j)))$]
	[conecta al jugador al juego.]

	\InterfazFuncion{Desconectarse}{\Inout{j}{juego}, \In{e}{jugador}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego$ conectado($e,j_0$)]
	{$j \igobs$ desconectarse($e, j_0$)}
	[$O()$]
	[desconecta al jugador del juego.]

	\InterfazFuncion{Moverse}{\Inout{j}{juego}, \In{e}{jugador}, \In{c}{coor}}{}
	[$j \igobs j_0 \land e \in$ jugadores($j_0$) $\yluego$ conectado($e,j_0$) $\land$ posExistente(mapa($j_0$))]
	{$j \igobs$ moverse($e, c, j_0$)}
	[$O()$]
	[mueve el jugador a la posición elegida. Si el movimiento es ilegal, sanciona al jugador o lo expulsa si excede el límite de sanciones. Aumenta los contadores de captura para otros jugadores donde corresponde y puede provocar la captura de pokémons.]

	\InterfazFuncion{Mapa}{\In{j}{juego}}{mapa}
	{alias($res$ = mapa($j$))}
	[$O(1)$]
	[devuelve el mapa del juego.]
	[$res$ no es modificable.]

	\InterfazFuncion{Jugadores}{\In{j}{juego}}{itBi(jugador)}
	{$res \igobs$ crearItBi($\secuvacia$, jugadores($j$)) $\land$ alias(esPermutacion(SecuSuby($res$), jugadores($j$)))}
	[$O(1)$]
	[devuelve un iterador del conjunto de jugadores registrados (no expulsados).]
	[el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador.]

	\InterfazFuncion{EstaConectado}{\In{j}{juego}, \In{e}{jugador}}{bool}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ estaConectado($e, j$)}
	[$O()$]
	[devuelve si el jugador está conectado al juego.]

	\InterfazFuncion{Sanciones}{\In{j}{juego}, \In{e}{jugador}}{nat}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ sanciones($e, j$)}
	[$O()$]
	[devuelve la cantidad de sanciones que el jugador posee.]

	\InterfazFuncion{Posicion}{\In{j}{juego}, \In{e}{jugador}}{coor}
	[$e \in$ jugadores($j$)]
	{$res \igobs$ posicion($e, j$)}
	[$O()$]
	[devuelve la posición actual del jugador.]

	\InterfazFuncion{Pokémons}{\In{j}{juego}}{itBi(tupla(pokemon, nat))}
	% TODO fucking tuplas
	% TODO fucking metapredicado alias e iteradores
	{$res \igobs$ crearItBi($\secuvacia$, pokemons($j$)) $\land$ alias(esPermutacion(SecuSuby($res$), pokemons($j$)))}
	[$O()$]
	[devuelve un iterador al conjunto de los pokémons y la cantidad de los mismos.]
	[el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador.]

	\InterfazFuncion{Expulsados}{\In{j}{juego}}{itBi(jugador)}
	{$res \igobs$ crearItBi($\secuvacia$, expulsados($j$)) $\land$ alias(esPermutacion(SecuSuby($res$), expulsados($j$)))}
	[$O()$]
	[devuelve un iterador del conjunto de jugadores expulsados.]
	[el iterador se invalida si y sólo si se elimina el elemento siguiente del iterador.]

	\InterfazFuncion{PosConPokémons}{\In{j}{juego}}{conj(coor)}
	{alias($res$ = posConPokémons(j))}
	[$O(1)$]
	[devuelve el conjunto de posiciones que contienen un pokémon.]
	[$res$ no es modificable.]

	\InterfazFuncion{PokémonEnPos}{\In{j}{juego}, \In{c}{coor}}{pokemon}
	[$c \ \land$ posConPokemon($j$)]
	{$res \igobs$ pokémonEnPos($c,j$)}
	[$O()$]
	[devuelve el pokémon que se encuentra en la posición.]

	\InterfazFuncion{PuedoAgregarPokémon}{\In{j}{juego}, \In{c}{coor}}{bool}
	{$res \igobs$ puedoAgregarPokémon($c,j$)}
	[$O()$]
	[devuelve si un nuevo pokémon puede ser agregado a esa posición (no debe haber ningún pokémon cerca).]

	\InterfazFuncion{HayPokémonCercano}{\In{j}{juego}, \In{c}{coor}}{bool}
	{$res \igobs$ hayPokémonCercano($c,j$)}
	[$O()$]
	[devuelve si hay algún pokémon cerca de la posición.]

	\InterfazFuncion{PosPókemonCercano}{\In{j}{juego}, \In{c}{coor}}{coor}
	[hayPokémonCercano($c,j$)]
	{$res \igobs$ posPokémonCercano($c,j$)}
	[$O()$]
	[devuelve el pokémon que se encuentra cerca de la posición.]

	% TODO hace falta exponer esto?
	% cambió la aridad, anotar en consideraciones
	\InterfazFuncion{EntrenadoresPosibles}{\In{j}{juego}, \In{c}{coor}}{conj(jugador)}
	[hayPokémonCercano($c,j$)]
	{$res \igobs$ entrenadoresPosibles($c,j$)}
	[$O()$]
	[devuelve el conjunto de jugadores esperando a capturar el pokémon que se encuentra en la posición.]
	[$res$ no es modificable.]

	\InterfazFuncion{IndiceRareza}{\In{j}{juego}, \In{pk}{pokemon}}{nat}
	[$pk \in$ pokemons($j$)]
	{$res \igobs$ indiceRareza($pk,j$)}
	[$O(|pk_{max}|)$]
	[calcula el índice de rareza de un pokémon.]

	\InterfazFuncion{CantPokémonsTotales}{\In{j}{juego}}{nat}
	{$res \igobs$ cantPokémonsTotales($j$)}
	[$O(1)$]
	[devuelve la cantidad de pokémons en juego.]

	\InterfazFuncion{CantMismaEspecie}{\In{j}{juego}, \In{pk}{pokemon}}{nat}
	[$pk \in$ pokemons($j$)]
	{$res \igobs$ cantMismaEspecie($j$)}
	[$O(|pk_{max}|)$]
	[devuelve la cantidad de pokémons de la especie especificada en juego.]

\end{Interfaz}

\begin{Representacion}

	\begin{Estructura}{Juego}[pokego]
		\begin{Tupla}[pokego]
			\tupItem{mapa}{mapa}
			\tupItem{pokemons}{diccString(nat)}
			\tupItem{posConPokemons}{conj(coor)}
			\tupItem{jugadores}{vector(infoJugador)}
			\tupItem{cantPokemons}{nat}
		\end{Tupla}

		\begin{Tupla}[infoJugador]
			\tupItem{sanciones}{nat}
			\tupItem{conectado?}{bool}
			\tupItem{posicion}{coor}
			\tupItem{pokemonsCapturados}{diccString(nat)}
		\end{Tupla}

	\end{Estructura}
	
	\TituloDis{Invariante de Representación del Diccionario}

	\begin{enumerate}
		
		\item Todas las coordenadas pertenecientes a posConPokemons pertenecen a las coordenadas válidas del mapa

		\item La suma de todos los significados del diccionario pokemons más la longitud de posConPokemons es igual a cantPokemons
		%TODO no se como meter bien la sumatoria en esta condicion :(
		
		\item No hay dos coordenadas pertenecientes a posConPokemons a menos de 5 de distancia
		
		\item Para cada miembro de jugadores, las claves de pokemonsCapturados pertenecen a las claves de pokemons

		\item En pokemons, para cada clave su significado es la suma de todos los significados de infoJugadores donde la clave existe y el jugador no tiene 5 sanciones, más la cantidad de coordenadas de posConPokemons donde el pokemon se encuentra
		%TODO no se como meter bien la sumatoria en esta condicion AGAIN
				
		\item Para cada miembro de jugadores, si el jugador tiene 5 sanciones no puede estar conectado 
		%TODO para hablar de jugadores, hablo de (forall i:infoJugador), alguno confirmeme la correctitud de esto pls
		
		\item Para cada miembro de jugadores, si el jugador esta conectado su posición tiene que pertenecer a las coordenadas válidas del mapa
		
		\item Para cada miembro de jugadores, si el jugador no esta conectado QUE CARAJO LE PASA A SU POSICION
		
		\item Para cada miembro de jugadores, si el jugador no esta conectado QUE CARAJO PASA CON EL DICCIONARIO POKEMONS CAPTURADOS
 
 %TODO uso la función claves, ¿se puede agregar a diccString pls?
		
	\end{enumerate}


	\Rep[pokego][e]{
	($\forall c$: coor)(c $\in$ e.posConPokemons $\implies$ c $\in$ coordenadas(e.mapa)) $\land$ ($\forall c,d$: coor)(c $\in$ e.posConPokemons $\land$ d $\in$ e.posConPokemons $\implies$ distEuclidea(c,d) == 0 $\lor$ distEuclidea(c,d) $>$ 25) $\land$ ($\forall i$:infoJugador)(i $\in$ e.jugadores $\implies$ claves(i.pokemonsCapturados) $\subseteq$ claves(e.pokemons)) $\land$ ($\forall i$:infoJugador)(i.sanciones == 5 $\implies$ $\neg$i.conectado) $\yluego$ ($\forall i$:infoJugador)(i.conectado $\implies$ i.posicion $\in$ coordenadas(e.mapa))
	}
	
	\TituloDis{Función de Abstracción}

	\Abs[pokego]{juego}[e]{j}{
		mapa(j) == e.mapa $\land$ ($\forall p:$ jugador))(p $\in$ jugadores(j) $\implies$ long(e.jugadores) $\geq$ p $\yluego$ estaConectado(p,j) == e.jugadores[p].conectado? $\land$ sanciones(p,j) == e.jugadores[p].sanciones $\land$ (estaConectado(p,j) $\impluego$ posicion(p,j) == e.jugadores[p].posicion)) $\land$ pokemons(j) == listaPoke(e.pokemons.claves, e.pokemons) $\land$ expulsados(j) == listaExpulsados(e.jugadores) $\land$ ($\forall c:$ coor) (c $\in$ posConPokemons(j) == c $\in$ e.posConPokemons) $\land$ TODO POKEMON EN POS, TODO MOV PARA CAPTURA
	}
	
	~

	\tadOperacion{listaPoke}{conj(pokemon)/cs, dicc(String{,}Nat)/dic}{multiconj(pokemon)}{cs $\subseteq$ claves(dic)}
	\tadOperacion{agregarPoke}{pokemon, nat}{multiconj(pokemon)}{}
	\tadOperacion{listaExpulsados}{TODO NO SE QUE PASARLE}{conj(jugador)}{}
	
	\tadAxioma{listasPoke(cs, dic)}
	{\IF vacia?(cs) THEN
		$\emptyset$
	ELSE
		$\langle$ agregarPoke(dameUno(cs),obtener(dameUno(cs),dic)) $\bigcup$ listasPoke(sinUno(cs), dic)
	FI}
	
	\tadAxioma{agregarPoke(p, n)}
	{\IF n == 0 THEN
		$\emptyset$
	ELSE
		$\langle$ Ag(p, agregarPoke(p, n-1))
	FI}
	%TODO dado que los jugadores estan implicitos, es una boludez decirle "cucha, para cada numero que tenes en jugadores, existe esa posicion en el vector" asi que también queda medio implicito ese observador, pero capaz hay una mejor forma de hacerlo y dejarlo retratado :)


\end{Representacion}


\begin{Algoritmos}

% TODO algoritmos

\end{Algoritmos}